<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake - Solana Seeker</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Grotesk', monospace, sans-serif;
            background: #000;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }
        
        html {
            overflow: hidden;
        }
        
        .fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .menu-container {
            width: 100%;
            max-width: 600px;
            padding: 40px;
            text-align: center;
        }

        .logo-big {
            font-size: 5em;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -3px;
        }

        .logo-accent {
            color: #14F195;
        }

        .tagline {
            color: #666;
            font-size: 1em;
            margin-bottom: 60px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .menu-button {
            width: 100%;
            max-width: 400px;
            padding: 20px 40px;
            margin: 15px auto;
            display: block;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Space Grotesk', monospace;
        }

        .menu-button:hover {
            background: #14F195;
            transform: translateY(-2px);
        }

        .menu-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .menu-button.secondary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #2a2a2a;
        }

        .menu-button.secondary:hover {
            background: #222;
            border-color: #333;
        }

        .wallet-display {
            margin-top: 40px;
            padding: 15px 25px;
            background: rgba(20, 241, 149, 0.1);
            border: 1px solid #14F195;
            border-radius: 8px;
            font-size: 0.9em;
            color: #14F195;
        }

        .loading-message {
            margin-top: 20px;
            color: #666;
            font-size: 0.9em;
        }

        .game-screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            position: relative;
        }

        .game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }

        .hud-left {
            display: flex;
            gap: 15px;
        }

        .stat-pill {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #1a1a1a;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.95em;
            color: #14F195;
            font-weight: 600;
            backdrop-filter: blur(10px);
        }

        .stat-pill .label {
            color: #666;
            font-size: 0.8em;
            margin-right: 10px;
            text-transform: uppercase;
        }

        .pause-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #1a1a1a;
            padding: 10px 20px;
            border-radius: 25px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            pointer-events: all;
            font-family: 'Space Grotesk', monospace;
            font-size: 0.9em;
        }

        .pause-btn:hover {
            background: #14F195;
            color: #000;
            border-color: #14F195;
        }

        canvas {
            border: 2px solid #1a1a1a;
            border-radius: 12px;
            display: block;
            background: #000;
            box-shadow: 0 0 80px rgba(20, 241, 149, 0.2);
        }

        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 30px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .overlay-title {
            font-size: 4em;
            font-weight: 700;
            letter-spacing: -2px;
        }

        .overlay-score {
            font-size: 1.5em;
            color: #666;
        }

        .overlay-score span {
            color: #14F195;
            font-size: 2em;
            font-weight: 700;
            display: block;
            margin-top: 10px;
        }

        .overlay-buttons {
            display: flex;
            gap: 15px;
        }

        .overlay-button {
            padding: 18px 40px;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Space Grotesk', monospace;
            transition: all 0.2s;
        }

        .overlay-button:hover {
            background: #14F195;
            transform: translateY(-2px);
        }

        .overlay-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .overlay-button.secondary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #2a2a2a;
        }

        .overlay-button.secondary:hover {
            background: #222;
        }

        .settings-container {
            width: 100%;
            max-width: 500px;
            padding: 40px;
        }

        .settings-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: -1px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .setting-row:last-child {
            border-bottom: none;
        }

        .setting-name {
            font-size: 1.1em;
            font-weight: 500;
        }

        .toggle {
            width: 56px;
            height: 30px;
            background: #1a1a1a;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
            border: 1px solid #2a2a2a;
        }

        .toggle.active {
            background: #14F195;
            border-color: #14F195;
        }

        .toggle-knob {
            width: 24px;
            height: 24px;
            background: #666;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .toggle.active .toggle-knob {
            left: 28px;
            background: #000;
        }

        .select-box {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            padding: 12px 20px;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            font-family: 'Space Grotesk', monospace;
            font-weight: 500;
            min-width: 140px;
        }

        .select-box option {
            background: #0a0a0a;
        }

        .back-button {
            width: 100%;
            margin-top: 40px;
        }

        .leaderboard-container {
            width: 100%;
            max-width: 500px;
            padding: 40px;
        }

        .leaderboard-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 40px;
            text-align: center;
            letter-spacing: -1px;
        }

        .leaderboard-list {
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 30px;
        }

        .leaderboard-list::-webkit-scrollbar {
            width: 6px;
        }

        .leaderboard-list::-webkit-scrollbar-thumb {
            background: #222;
            border-radius: 3px;
        }

        .leaderboard-entry {
            display: flex;
            align-items: center;
            padding: 18px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .leaderboard-entry:last-child {
            border-bottom: none;
        }

        .entry-rank {
            width: 40px;
            font-weight: 700;
            color: #14F195;
            font-size: 1.1em;
        }

        .entry-name {
            flex: 1;
            font-size: 1.05em;
        }

        .entry-score {
            color: #666;
            font-weight: 600;
            font-size: 1.05em;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        window.addEventListener("keydown", function(e) {
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].indexOf(e.key) > -1) {
                e.preventDefault();
            }
        }, false);

        const { useState, useEffect, useRef, useCallback } = React;
        const { Connection, PublicKey, SystemProgram, Transaction, TransactionInstruction } = window.solanaWeb3;

        // Program ID
        const PROGRAM_ID = new PublicKey('86KbYQVcxA2DDj3VGXwfPA65GZNoGKqoQB8KwKsA8zCH');
        const connection = new Connection('https://api.devnet.solana.com', 'confirmed');

        const GRID_SIZE = 20;
        const CELL_SIZE = 24;
        const INITIAL_SNAKE = [{x: 10, y: 10}];
        const INITIAL_DIRECTION = {x: 1, y: 0};

        const audioContext = typeof AudioContext !== 'undefined' ? new AudioContext() : null;

        function playSound(frequency, duration, volume) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function SnakeGame() {
            const [screen, setScreen] = useState('menu');
            const [snake, setSnake] = useState(INITIAL_SNAKE);
            const [direction, setDirection] = useState(INITIAL_DIRECTION);
            const [food, setFood] = useState({x: 15, y: 15});
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [obstacles, setObstacles] = useState([]);
            const [speedBoost, setSpeedBoost] = useState(false);
            const [timer, setTimer] = useState(60);
            
            const [settings, setSettings] = useState({
                sound: true,
                vibration: true,
                difficulty: 'medium',
                gameMode: 'classic'
            });

            const [wallet, setWallet] = useState(null);
            const [playerName, setPlayerName] = useState('');
            const [leaderboard, setLeaderboard] = useState([]);
            const [submittingScore, setSubmittingScore] = useState(false);
            const [loadingLeaderboard, setLoadingLeaderboard] = useState(false);

            const canvasRef = useRef(null);
            const gameLoopRef = useRef(null);
            const directionRef = useRef(INITIAL_DIRECTION);

            const GAME_SPEEDS = {
                easy: 200,
                medium: 150,
                hard: 100
            };

            // Get player PDA
            const getPlayerPDA = async (walletPubkey) => {
                const seeds = [
                    new TextEncoder().encode('player'),
                    walletPubkey.toBytes()
                ];
                const [pda] = await PublicKey.findProgramAddress(seeds, PROGRAM_ID);
                return pda;
            };

            // Get leaderboard PDA
            const getLeaderboardPDA = async () => {
                const seeds = [new TextEncoder().encode('leaderboard')];
                const [pda] = await PublicKey.findProgramAddress(seeds, PROGRAM_ID);
                return pda;
            };

            const connectWallet = async () => {
                try {
                    if (window.solana && window.solana.isPhantom) {
                        const response = await window.solana.connect();
                        const pubkey = response.publicKey.toString();
                        setWallet(pubkey);
                        
                        const name = prompt("Enter your player name (max 32 characters):");
                        if (name && name.length > 0 && name.length <= 32) {
                            setPlayerName(name);
                            await initializePlayer(response.publicKey, name);
                        }
                    } else {
                        alert('Please install Phantom wallet');
                        window.open('https://phantom.app/', '_blank');
                    }
                } catch (err) {
                    console.error('Wallet connection error:', err);
                    alert('Failed to connect wallet: ' + err.message);
                }
            };

            const initializePlayer = async (walletPubkey, name) => {
                try {
                    const playerPDA = await getPlayerPDA(walletPubkey);
                    
                    // Check if player account already exists
                    const accountInfo = await connection.getAccountInfo(playerPDA);
                    if (accountInfo) {
                        console.log('Player account already exists');
                        return;
                    }

                    // Create name buffer
                    const nameBytes = new TextEncoder().encode(name);
                    const nameBuffer = new Uint8Array(32);
                    nameBuffer.set(nameBytes);

                    // Create instruction data
                    const instructionData = new Uint8Array(1 + 32);
                    instructionData[0] = 0; // initialize_player discriminator
                    instructionData.set(nameBuffer, 1);

                    const instruction = new TransactionInstruction({
                        programId: PROGRAM_ID,
                        keys: [
                            { pubkey: playerPDA, isSigner: false, isWritable: true },
                            { pubkey: walletPubkey, isSigner: true, isWritable: true },
                            { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
                        ],
                        data: instructionData
                    });

                    const transaction = new Transaction().add(instruction);
                    transaction.feePayer = walletPubkey;
                    transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;

                    const signed = await window.solana.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);
                    
                    console.log('Player initialized:', signature);
                } catch (err) {
                    console.error('Failed to initialize player:', err);
                }
            };

            const disconnectWallet = () => {
                if (window.solana) {
                    window.solana.disconnect();
                    setWallet(null);
                    setPlayerName('');
                }
            };

            const loadLeaderboard = async () => {
                try {
                    setLoadingLeaderboard(true);
                    const leaderboardPDA = await getLeaderboardPDA();
                    
                    const accountInfo = await connection.getAccountInfo(leaderboardPDA);
                    if (!accountInfo) {
                        console.log('Leaderboard not initialized yet');
                        setLeaderboard([]);
                        return;
                    }

                    setLeaderboard([]);
                } catch (err) {
                    console.error('Failed to load leaderboard:', err);
                    setLeaderboard([]);
                } finally {
                    setLoadingLeaderboard(false);
                }
            };

            useEffect(() => {
                loadLeaderboard();
            }, []);

            const generateFood = useCallback(() => {
                let newFood;
                let attempts = 0;
                
                do {
                    newFood = {
                        x: Math.floor(Math.random() * GRID_SIZE),
                        y: Math.floor(Math.random() * GRID_SIZE)
                    };
                    attempts++;
                } while (
                    attempts < 100 &&
                    (obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y) ||
                     snake.some(seg => seg.x === newFood.x && seg.y === newFood.y))
                );
                
                return newFood;
            }, [obstacles, snake]);

            const generateObstacles = useCallback(() => {
                const numObstacles = settings.gameMode === 'walls' ? 10 : 0;
                const newObstacles = [];
                
                for (let i = 0; i < numObstacles; i++) {
                    let obstacle;
                    let attempts = 0;
                    
                    do {
                        obstacle = {
                            x: Math.floor(Math.random() * GRID_SIZE),
                            y: Math.floor(Math.random() * GRID_SIZE)
                        };
                        attempts++;
                    } while (
                        attempts < 100 &&
                        (newObstacles.some(obs => obs.x === obstacle.x && obs.y === obstacle.y) ||
                         INITIAL_SNAKE.some(seg => seg.x === obstacle.x && seg.y === obstacle.y) ||
                         (obstacle.x === 15 && obstacle.y === 15))
                    );
                    
                    newObstacles.push(obstacle);
                }
                
                return newObstacles;
            }, [settings.gameMode]);

            const vibrate = (pattern) => {
                if (settings.vibration && navigator.vibrate) {
                    navigator.vibrate(pattern);
                }
            };

            const handleDirectionChange = (newDirection) => {
                if (screen !== 'playing') return;
                
                const currentDir = directionRef.current;
                
                if (newDirection.x === -currentDir.x && newDirection.y === -currentDir.y) {
                    return;
                }
                
                directionRef.current = newDirection;
                setDirection(newDirection);
                vibrate(10);
            };

            const startGame = () => {
                setSnake(INITIAL_SNAKE);
                setDirection(INITIAL_DIRECTION);
                directionRef.current = INITIAL_DIRECTION;
                setFood(generateFood());
                setScore(0);
                setSpeedBoost(false);
                setTimer(60);
                
                if (settings.gameMode === 'walls') {
                    setObstacles(generateObstacles());
                } else {
                    setObstacles([]);
                }
                
                setScreen('playing');
            };

            const submitScoreToBlockchain = async (finalScore) => {
                if (!wallet || !playerName) {
                    console.log('No wallet connected, skipping blockchain submission');
                    return;
                }

                try {
                    setSubmittingScore(true);
                    const walletPubkey = new PublicKey(wallet);
                    const playerPDA = await getPlayerPDA(walletPubkey);
                    
                    // Create score buffer (4 bytes, little-endian)
                    const scoreBuffer = new Uint8Array(4);
                    new DataView(scoreBuffer.buffer).setUint32(0, finalScore, true);
                    
                    // Create instruction data
                    const instructionData = new Uint8Array(1 + 4);
                    instructionData[0] = 1; // submit_score discriminator
                    instructionData.set(scoreBuffer, 1);
                    
                    const instruction = new TransactionInstruction({
                        programId: PROGRAM_ID,
                        keys: [
                            { pubkey: playerPDA, isSigner: false, isWritable: true },
                            { pubkey: walletPubkey, isSigner: true, isWritable: false },
                        ],
                        data: instructionData
                    });

                    const transaction = new Transaction().add(instruction);
                    transaction.feePayer = walletPubkey;
                    transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;

                    const signed = await window.solana.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signed.serialize());
                    await connection.confirmTransaction(signature);
                    
                    console.log('Score submitted to blockchain:', signature);
                    
                    // Update local leaderboard
                    const newEntry = { rank: 0, name: playerName, score: finalScore };
                    setLeaderboard(prev => {
                        const updated = [...prev, newEntry]
                            .sort((a, b) => b.score - a.score)
                            .slice(0, 100)
                            .map((entry, idx) => ({ ...entry, rank: idx + 1 }));
                        return updated;
                    });
                } catch (err) {
                    console.error('Failed to submit score to blockchain:', err);
                    alert('Failed to submit score: ' + err.message);
                } finally {
                    setSubmittingScore(false);
                }
            };

            const submitScore = async (finalScore) => {
                if (finalScore > highScore) {
                    setHighScore(finalScore);
                }
                
                if (wallet && playerName) {
                    await submitScoreToBlockchain(finalScore);
                }
            };

            const checkCollision = useCallback((head) => {
                if (settings.gameMode === 'portal') {
                    return false;
                }
                
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    return true;
                }
                
                if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) {
                    return true;
                }
                
                for (let segment of snake) {
                    if (head.x === segment.x && head.y === segment.y) {
                        return true;
                    }
                }
                
                return false;
            }, [snake, obstacles, settings.gameMode]);

            const gameLoop = useCallback(() => {
                setSnake(prevSnake => {
                    let head = {
                        x: prevSnake[0].x + directionRef.current.x,
                        y: prevSnake[0].y + directionRef.current.y
                    };

                    if (settings.gameMode === 'portal') {
                        if (head.x < 0) head.x = GRID_SIZE - 1;
                        if (head.x >= GRID_SIZE) head.x = 0;
                        if (head.y < 0) head.y = GRID_SIZE - 1;
                        if (head.y >= GRID_SIZE) head.y = 0;
                    }

                    if (checkCollision(head)) {
                        setScreen('gameOver');
                        submitScore(score);
                        if (settings.sound) playSound(100, 0.3, 0.3);
                        vibrate([200, 100, 200]);
                        return prevSnake;
                    }

                    const newSnake = [head, ...prevSnake];

                    if (head.x === food.x && head.y === food.y) {
                        const points = settings.gameMode === 'speed' ? 20 : 10;
                        setScore(s => s + points);
                        setFood(generateFood());
                        if (settings.sound) playSound(800, 0.1, 0.2);
                        vibrate(50);
                        
                        if (settings.gameMode === 'speed') {
                            setSpeedBoost(true);
                            setTimeout(() => setSpeedBoost(false), 3000);
                        }
                    } else {
                        newSnake.pop();
                    }

                    return newSnake;
                });
            }, [food, checkCollision, score, generateFood, settings.sound, settings.vibration, settings.gameMode]);

            useEffect(() => {
                if (screen === 'playing') {
                    let speed = GAME_SPEEDS[settings.difficulty];
                    
                    if (settings.gameMode === 'speed' && speedBoost) {
                        speed = Math.max(speed - 50, 50);
                    }
                    
                    gameLoopRef.current = setInterval(gameLoop, speed);
                    return () => clearInterval(gameLoopRef.current);
                }
            }, [screen, gameLoop, settings.difficulty, settings.gameMode, speedBoost]);

            useEffect(() => {
                if (screen === 'playing' && settings.gameMode === 'survival') {
                    const timerInterval = setInterval(() => {
                        setTimer(t => {
                            if (t <= 1) {
                                setScreen('gameOver');
                                submitScore(score);
                                return 0;
                            }
                            return t - 1;
                        });
                    }, 1000);
                    
                    return () => clearInterval(timerInterval);
                }
            }, [screen, settings.gameMode, score]);

            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (screen === 'playing') {
                        const currentDir = directionRef.current;

                        if (e.key === 'ArrowUp' && currentDir.y === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 0, y: -1});
                        } else if (e.key === 'ArrowDown' && currentDir.y === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 0, y: 1});
                        } else if (e.key === 'ArrowLeft' && currentDir.x === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: -1, y: 0});
                        } else if (e.key === 'ArrowRight' && currentDir.x === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 1, y: 0});
                        } else if (e.key === 'Escape' || e.key === ' ') {
                            e.preventDefault();
                            setScreen('paused');
                        }
                    } else if (screen === 'paused' && (e.key === 'Escape' || e.key === ' ')) {
                        e.preventDefault();
                        setScreen('playing');
                    }
                };

                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [screen]);

            useEffect(() => {
                if (screen !== 'playing') return;

                let touchStartX = 0;
                let touchStartY = 0;

                const handleTouchStart = (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                };

                const handleTouchEnd = (e) => {
                    const touchEndX = e.changedTouches[0].screenX;
                    const touchEndY = e.changedTouches[0].screenY;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    const minSwipeDistance = 30;

                    if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                        return;
                    }

                    const currentDir = directionRef.current;

                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0 && currentDir.x === 0) {
                            handleDirectionChange({x: 1, y: 0});
                        } else if (deltaX < 0 && currentDir.x === 0) {
                            handleDirectionChange({x: -1, y: 0});
                        }
                    } else {
                        if (deltaY > 0 && currentDir.y === 0) {
                            handleDirectionChange({x: 0, y: 1});
                        } else if (deltaY < 0 && currentDir.y === 0) {
                            handleDirectionChange({x: 0, y: -1});
                        }
                    }
                };

                window.addEventListener('touchstart', handleTouchStart, {passive: true});
                window.addEventListener('touchend', handleTouchEnd, {passive: true});

                return () => {
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchend', handleTouchEnd);
                };
            }, [screen]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (obstacles.length > 0) {
                    ctx.fillStyle = '#1a1a1a';
                    obstacles.forEach(obs => {
                        ctx.fillRect(
                            obs.x * CELL_SIZE,
                            obs.y * CELL_SIZE,
                            CELL_SIZE - 1,
                            CELL_SIZE - 1
                        );
                    });
                }

                const snakeColor = speedBoost ? '#FFD700' : '#14F195';
                ctx.fillStyle = snakeColor;
                
                snake.forEach((segment) => {
                    ctx.fillRect(
                        segment.x * CELL_SIZE + 1,
                        segment.y * CELL_SIZE + 1,
                        CELL_SIZE - 2,
                        CELL_SIZE - 2
                    );
                });

                ctx.fillStyle = '#9945FF';
                ctx.beginPath();
                ctx.arc(
                    food.x * CELL_SIZE + CELL_SIZE / 2,
                    food.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

            }, [snake, food, obstacles, speedBoost]);

            if (screen === 'menu') {
                return (
                    <div className="fullscreen">
                        <div className="menu-container">
                            <div className="logo-big">
                                <span className="logo-accent">◢</span> SNAKE
                            </div>
                            <div className="tagline">SOLANA SEEKER</div>
                            
                            <button className="menu-button" onClick={startGame}>
                                START GAME
                            </button>
                            <button className="menu-button secondary" onClick={() => setScreen('settings')}>
                                SETTINGS
                            </button>
                            <button className="menu-button secondary" onClick={() => setScreen('leaderboard')}>
                                LEADERBOARD
                            </button>
                            {!wallet ? (
                                <button className="menu-button secondary" onClick={connectWallet}>
                                    CONNECT WALLET
                                </button>
                            ) : (
                                <button className="menu-button secondary" onClick={disconnectWallet}>
                                    DISCONNECT
                                </button>
                            )}

                            {wallet && (
                                <div className="wallet-display">
                                    {playerName || 'Connected'} • {wallet.slice(0,4)}...{wallet.slice(-4)}
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (screen === 'settings') {
                return (
                    <div className="fullscreen">
                        <div className="settings-container">
                            <div className="settings-title">SETTINGS</div>
                            
                            <div className="setting-row">
                                <div className="setting-name">Sound</div>
                                <div 
                                    className={`toggle ${settings.sound ? 'active' : ''}`}
                                    onClick={() => setSettings({...settings, sound: !settings.sound})}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Vibration</div>
                                <div 
                                    className={`toggle ${settings.vibration ? 'active' : ''}`}
                                    onClick={() => setSettings({...settings, vibration: !settings.vibration})}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Difficulty</div>
                                <select 
                                    className="select-box"
                                    value={settings.difficulty}
                                    onChange={(e) => setSettings({...settings, difficulty: e.target.value})}
                                >
                                    <option value="easy">Easy</option>
                                    <option value="medium">Medium</option>
                                    <option value="hard">Hard</option>
                                </select>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Game Mode</div>
                                <select 
                                    className="select-box"
                                    value={settings.gameMode}
                                    onChange={(e) => setSettings({...settings, gameMode: e.target.value})}
                                >
                                    <option value="classic">Classic</option>
                                    <option value="walls">Walls</option>
                                    <option value="portal">Portal</option>
                                    <option value="speed">Speed</option>
                                    <option value="survival">Survival</option>
                                </select>
                            </div>

                            <button className="menu-button back-button" onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            if (screen === 'leaderboard') {
                return (
                    <div className="fullscreen">
                        <div className="leaderboard-container">
                            <div className="leaderboard-title">LEADERBOARD</div>
                            
                            <div className="leaderboard-list">
                                {loadingLeaderboard ? (
                                    <div style={{textAlign: 'center', color: '#666', padding: '40px 20px', fontSize: '1.1em'}}>
                                        Loading...
                                    </div>
                                ) : leaderboard.length === 0 ? (
                                    <div style={{textAlign: 'center', color: '#666', padding: '40px 20px', fontSize: '1.1em'}}>
                                        No scores yet.<br/>
                                        Connect wallet and play to get on the leaderboard!
                                    </div>
                                ) : (
                                    leaderboard.map((entry) => (
                                        <div key={entry.rank} className="leaderboard-entry">
                                            <div className="entry-rank">#{entry.rank}</div>
                                            <div className="entry-name">{entry.name}</div>
                                            <div className="entry-score">{entry.score}</div>
                                        </div>
                                    ))
                                )}
                            </div>

                            <button className="menu-button" onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="fullscreen">
                    <div className="game-screen">
                        <div className="game-hud">
                            <div className="hud-left">
                                <div className="stat-pill">
                                    <span className="label">SCORE</span>
                                    {score}
                                </div>
                                {settings.gameMode === 'survival' && (
                                    <div className="stat-pill">
                                        <span className="label">TIME</span>
                                        {timer}s
                                    </div>
                                )}
                                <div className="stat-pill">
                                    <span className="label">LENGTH</span>
                                    {snake.length}
                                </div>
                            </div>
                            {screen === 'playing' && (
                                <button className="pause-btn" onClick={() => setScreen('paused')}>
                                    PAUSE
                                </button>
                            )}
                        </div>

                        <canvas
                            ref={canvasRef}
                            width={GRID_SIZE * CELL_SIZE}
                            height={GRID_SIZE * CELL_SIZE}
                        />

                        {screen === 'paused' && (
                            <div className="overlay">
                                <div className="overlay-title">PAUSED</div>
                                <div className="overlay-buttons">
                                    <button className="overlay-button" onClick={() => setScreen('playing')}>
                                        RESUME
                                    </button>
                                    <button className="overlay-button secondary" onClick={() => setScreen('menu')}>
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}

                        {screen === 'gameOver' && (
                            <div className="overlay">
                                <div className="overlay-title">GAME OVER</div>
                                <div className="overlay-score">
                                    FINAL SCORE
                                    <span>{score}</span>
                                </div>
                                {submittingScore && (
                                    <div className="loading-message">
                                        Submitting to blockchain...
                                    </div>
                                )}
                                <div className="overlay-buttons">
                                    <button 
                                        className="overlay-button" 
                                        onClick={startGame}
                                        disabled={submittingScore}
                                    >
                                        PLAY AGAIN
                                    </button>
                                    <button 
                                        className="overlay-button secondary" 
                                        onClick={() => setScreen('menu')}
                                        disabled={submittingScore}
                                    >
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<SnakeGame />, document.getElementById('root'));
    </script>
</body>
</html>
