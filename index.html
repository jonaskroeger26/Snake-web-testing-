<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake - Solana</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@bonfida/spl-name-service@2.1.0/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Space Grotesk', monospace;
            background: #000;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }
        .fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .menu-container {
            width: 100%;
            max-width: 600px;
            padding: 40px;
            text-align: center;
        }
        .logo-big {
            font-size: 5em;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: -3px;
        }
        .logo-accent { color: #14F195; }
        .tagline {
            color: #666;
            font-size: 1em;
            margin-bottom: 60px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        .menu-button {
            width: 100%;
            max-width: 400px;
            padding: 20px 40px;
            margin: 15px auto;
            display: block;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Space Grotesk';
        }
        .menu-button:hover {
            background: #14F195;
            transform: translateY(-2px);
        }
        .menu-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .menu-button.secondary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #2a2a2a;
        }
        .menu-button.secondary:hover {
            background: #222;
        }
        .wallet-display {
            margin-top: 40px;
            padding: 15px 25px;
            background: rgba(20, 241, 149, 0.1);
            border: 1px solid #14F195;
            border-radius: 8px;
            font-size: 0.9em;
            color: #14F195;
        }
        .game-screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            position: relative;
        }
        .game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        .hud-left { display: flex; gap: 15px; }
        .stat-pill {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #1a1a1a;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.95em;
            color: #14F195;
            font-weight: 600;
        }
        .stat-pill .label {
            color: #666;
            font-size: 0.8em;
            margin-right: 10px;
            text-transform: uppercase;
        }
        .pause-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #1a1a1a;
            padding: 10px 20px;
            border-radius: 25px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            pointer-events: all;
            font-family: 'Space Grotesk';
            font-size: 0.9em;
        }
        .pause-btn:hover { background: #14F195; color: #000; }
        canvas {
            border: 2px solid #1a1a1a;
            border-radius: 12px;
            background: #000;
            box-shadow: 0 0 80px rgba(20, 241, 149, 0.2);
        }
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 30px;
            z-index: 100;
        }
        .overlay-title {
            font-size: 4em;
            font-weight: 700;
            letter-spacing: -2px;
        }
        .overlay-score {
            font-size: 1.5em;
            color: #666;
        }
        .overlay-score span {
            color: #14F195;
            font-size: 2em;
            font-weight: 700;
            display: block;
            margin-top: 10px;
        }
        .overlay-buttons { display: flex; gap: 15px; }
        .overlay-button {
            padding: 18px 40px;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Space Grotesk';
            transition: all 0.2s;
        }
        .overlay-button:hover {
            background: #14F195;
            transform: translateY(-2px);
        }
        .overlay-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .overlay-button.secondary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #2a2a2a;
        }
        .overlay-button.secondary:hover { background: #222; }
        .settings-container {
            width: 100%;
            max-width: 500px;
            padding: 40px;
        }
        .settings-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 40px;
            text-align: center;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid #1a1a1a;
        }
        .setting-name {
            font-size: 1.1em;
            font-weight: 500;
        }
        .toggle {
            width: 56px;
            height: 30px;
            background: #1a1a1a;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
            border: 1px solid #2a2a2a;
        }
        .toggle.active { background: #14F195; }
        .toggle-knob {
            width: 24px;
            height: 24px;
            background: #666;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }
        .toggle.active .toggle-knob {
            left: 28px;
            background: #000;
        }
        .select-box {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            padding: 12px 20px;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            font-family: 'Space Grotesk';
            font-weight: 500;
            min-width: 140px;
        }
        .leaderboard-container {
            width: 100%;
            max-width: 600px;
            padding: 40px;
        }
        .leaderboard-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }
        .leaderboard-subtitle {
            color: #666;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .leaderboard-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }
        .filter-select {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            padding: 10px 16px;
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
            font-family: 'Space Grotesk';
            font-weight: 500;
        }
        .leaderboard-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 30px;
        }
        .leaderboard-entry {
            display: flex;
            align-items: center;
            padding: 18px 0;
            border-bottom: 1px solid #1a1a1a;
        }
        .entry-rank {
            width: 40px;
            font-weight: 700;
            color: #14F195;
            font-size: 1.1em;
        }
        .entry-name {
            flex: 1;
            font-size: 1.05em;
        }
        .entry-score {
            color: #666;
            font-weight: 600;
            font-size: 1.05em;
        }
        .loading-message {
            color: #14F195;
            font-size: 0.9em;
            margin-top: 15px;
        }
    </style>
</head>
<body><!-- ui-v2 -->
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { Connection, PublicKey } = window.solanaWeb3;

        // Supabase credentials
        const SUPABASE_URL = 'https://aukbtnujqzilrqxgelxq.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF1a2J0bnVqcXppbHJxeGdlbHhxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAxMTc1NjQsImV4cCI6MjA4NTY5MzU2NH0.PGwNORkCQn_EztvA4EKoWYQZ3xlhS1a9g-NGPSTL6d4';
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        
        const connection = new Connection('https://api.devnet.solana.com', 'confirmed');

        const GRID_SIZE = 20;
        const CELL_SIZE = 24;
        const INITIAL_SNAKE = [{x: 10, y: 10}];
        const INITIAL_DIRECTION = {x: 1, y: 0};

        const audioContext = typeof AudioContext !== 'undefined' ? new AudioContext() : null;

        function playSound(frequency, duration, volume) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Fetch SNS (.skr) name - domains are linked to wallet addresses
        async function getDisplayName(walletAddress) {
            console.log('üöÄüöÄüöÄ [SNS Lookup] ========== FUNCTION CALLED ========== üöÄüöÄüöÄ');
            console.log('[SNS Lookup] Starting lookup for:', walletAddress);
            console.log('[SNS Lookup] ========== STARTING SOLSCAN API LOOKUP ==========');
            console.log('[SNS Lookup] Wallet address:', walletAddress);
            
            try {
                // QuickNode SNS API support
                const QUICKNODE_ENDPOINT = 'https://bold-boldest-knowledge.solana-mainnet.quiknode.pro/d31ebc9ab7a456235231f62ce1b43c447712538f/';
                
                // Try Solscan API for .skr domains (account metadata)
                // Note: Pro API requires authentication, trying public endpoint first
                
                try {
                    // Try public Solscan API first (no auth required)
                    console.log('[SNS Lookup] üîç Step 1: Trying public Solscan API...');
                    const publicSolscanUrl = `https://public-api.solscan.io/account/${walletAddress}`;
                    console.log('[SNS Lookup] Public Solscan URL:', publicSolscanUrl);
                    
                    const publicSolscanResponse = await fetch(publicSolscanUrl, {
                        method: 'GET',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        }
                    }).catch(fetchError => {
                        console.error('[SNS Lookup] ‚ùå Public Solscan fetch error:', fetchError);
                        console.error('[SNS Lookup] Error type:', fetchError.constructor.name);
                        console.error('[SNS Lookup] Error message:', fetchError.message);
                        throw fetchError;
                    });
                    
                    console.log('[SNS Lookup] Public Solscan status:', publicSolscanResponse.status, publicSolscanResponse.statusText);
                    
                    if (publicSolscanResponse.ok) {
                        const publicSolscanData = await publicSolscanResponse.json().catch(jsonError => {
                            console.error('[SNS Lookup] ‚ùå Failed to parse public Solscan JSON:', jsonError);
                            return null;
                        });
                        
                        if (publicSolscanData) {
                            console.log('[SNS Lookup] Public Solscan response keys:', Object.keys(publicSolscanData || {}));
                            
                            // Recursively search for .skr domain
                            function findSkrDomain(obj, path = '') {
                                if (!obj || typeof obj !== 'object') return null;
                                
                                for (const [key, value] of Object.entries(obj)) {
                                    const currentPath = path ? `${path}.${key}` : key;
                                    
                                    if (typeof value === 'string' && value.endsWith('.skr')) {
                                        console.log(`[SNS Lookup] ‚úÖ Found .skr domain at path: ${currentPath} = ${value}`);
                                        return value;
                                    }
                                    
                                    if (typeof value === 'object' && value !== null) {
                                        const found = findSkrDomain(value, currentPath);
                                        if (found) return found;
                                    }
                                    
                                    if (Array.isArray(value)) {
                                        for (let i = 0; i < value.length; i++) {
                                            const found = findSkrDomain(value[i], `${currentPath}[${i}]`);
                                            if (found) return found;
                                        }
                                    }
                                }
                                return null;
                            }
                            
                            const skrDomain = findSkrDomain(publicSolscanData);
                            if (skrDomain) {
                                console.log('[SNS Lookup] ‚úÖ Returning .skr domain from public Solscan API:', skrDomain);
                                return skrDomain;
                            }
                        }
                    }
                } catch (publicSolscanError) {
                    console.log('[SNS Lookup] Public Solscan API failed:', publicSolscanError.message);
                    console.log('[SNS Lookup] Error stack:', publicSolscanError.stack);
                }
                
                // Try Pro API as fallback (may require auth)
                try {
                    console.log('[SNS Lookup] üîç Step 2: Trying Solscan Pro API v2.0 account/metadata...');
                    const proSolscanUrl = `https://pro-api.solscan.io/v2.0/account/metadata?address=${walletAddress}`;
                    console.log('[SNS Lookup] Pro Solscan URL:', proSolscanUrl);
                    
                    const proSolscanResponse = await fetch(proSolscanUrl, {
                        method: 'GET',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        }
                    }).catch(fetchError => {
                        console.error('[SNS Lookup] ‚ùå Pro Solscan fetch error:', fetchError);
                        console.error('[SNS Lookup] Error type:', fetchError.constructor.name);
                        console.error('[SNS Lookup] Error message:', fetchError.message);
                        throw fetchError;
                    });
                    
                    console.log('[SNS Lookup] Pro Solscan status:', proSolscanResponse.status, proSolscanResponse.statusText);
                    
                    if (proSolscanResponse.ok) {
                        const proSolscanData = await proSolscanResponse.json().catch(jsonError => {
                            console.error('[SNS Lookup] ‚ùå Failed to parse Pro Solscan JSON:', jsonError);
                            return null;
                        });
                        
                        if (proSolscanData) {
                            console.log('[SNS Lookup] Pro Solscan response keys:', Object.keys(proSolscanData || {}));
                            
                            // Recursively search for .skr domain
                            function findSkrDomain(obj, path = '') {
                                if (!obj || typeof obj !== 'object') return null;
                                
                                for (const [key, value] of Object.entries(obj)) {
                                    const currentPath = path ? `${path}.${key}` : key;
                                    
                                    if (typeof value === 'string' && value.endsWith('.skr')) {
                                        console.log(`[SNS Lookup] ‚úÖ Found .skr domain at path: ${currentPath} = ${value}`);
                                        return value;
                                    }
                                    
                                    if (typeof value === 'object' && value !== null) {
                                        const found = findSkrDomain(value, currentPath);
                                        if (found) return found;
                                    }
                                    
                                    if (Array.isArray(value)) {
                                        for (let i = 0; i < value.length; i++) {
                                            const found = findSkrDomain(value[i], `${currentPath}[${i}]`);
                                            if (found) return found;
                                        }
                                    }
                                }
                                return null;
                            }
                            
                            const skrDomain = findSkrDomain(proSolscanData);
                            if (skrDomain) {
                                console.log('[SNS Lookup] ‚úÖ Returning .skr domain from Pro Solscan API:', skrDomain);
                                return skrDomain;
                            }
                        }
                    } else {
                        const errorText = await proSolscanResponse.text().catch(() => '');
                        console.log('[SNS Lookup] Pro Solscan API error response:', proSolscanResponse.status, errorText.substring(0, 200));
                    }
                } catch (proSolscanError) {
                    console.log('[SNS Lookup] Pro Solscan API exception:', proSolscanError.message);
                    console.log('[SNS Lookup] Error stack:', proSolscanError.stack);
                }
                
                console.log('[SNS Lookup] ========== SOLSCAN API LOOKUP COMPLETE ==========');
                
                // Try Solana Mobile API for .skr domains (Seeker ID system)
                try {
                    console.log('[SNS Lookup] Trying Solana Mobile API for .skr domains...');
                    const solanaMobileEndpoints = [
                        `https://api.solanamobile.com/v1/wallet/${walletAddress}/domains`,
                        `https://api.solanamobile.com/v1/seeker/${walletAddress}`,
                        `https://api.solanamobile.com/wallet/${walletAddress}/domains`,
                        `https://solanamobile.com/api/wallet/${walletAddress}/domains`
                    ];
                    
                    for (const endpoint of solanaMobileEndpoints) {
                        try {
                            console.log('[SNS Lookup] Trying Solana Mobile endpoint:', endpoint);
                            const response = await fetch(endpoint, {
                                method: 'GET',
                                headers: { 'Content-Type': 'application/json' }
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                console.log('[SNS Lookup] Solana Mobile API response:', data);
                                
                                // Check for .skr domain in response
                                let skrDomain = null;
                                if (data && typeof data === 'object') {
                                    if (data.domain && data.domain.endsWith('.skr')) {
                                        skrDomain = data.domain;
                                    } else if (data.seekerId && data.seekerId.endsWith('.skr')) {
                                        skrDomain = data.seekerId;
                                    } else if (Array.isArray(data.domains)) {
                                        skrDomain = data.domains.find(d => d && d.endsWith('.skr'));
                                    }
                                }
                                
                                if (skrDomain) {
                                    console.log('[SNS Lookup] ‚úÖ Returning .skr domain from Solana Mobile API:', skrDomain);
                                    return skrDomain;
                                }
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                } catch (solanaMobileError) {
                    console.log('[SNS Lookup] Solana Mobile API exception:', solanaMobileError.message);
                }
                
                // Try SNS API v2 endpoint (for standard SNS domains)
                try {
                    console.log('[SNS Lookup] Trying SNS API v2 /user/domains endpoint...');
                    const snsApiResponse = await fetch(`https://api.sns.id/v2/user/domains/${walletAddress}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    console.log('[SNS Lookup] SNS API v2 status:', snsApiResponse.status);
                    
                    if (snsApiResponse.ok) {
                        const snsData = await snsApiResponse.json();
                        console.log('[SNS Lookup] SNS API v2 response:', snsData);
                        console.log('[SNS Lookup] Response type:', typeof snsData, 'Keys:', Object.keys(snsData || {}));
                        
                        // Response format can be:
                        // 1. { "walletAddress": ["domain1", "domain2", ...] }
                        // 2. { "domains": ["domain1", "domain2", ...] }
                        // 3. { "data": { "walletAddress": [...] } }
                        // 4. Direct array: ["domain1", "domain2", ...]
                        let domains = [];
                        
                        if (Array.isArray(snsData)) {
                            domains = snsData;
                        } else if (snsData && typeof snsData === 'object') {
                            // Try different possible response formats
                            domains = snsData[walletAddress] || 
                                     snsData.domains || 
                                     snsData.data?.domains ||
                                     snsData.data?.[walletAddress] ||
                                     (snsData.data && Array.isArray(snsData.data) ? snsData.data : []);
                        }
                        
                        console.log('[SNS Lookup] Extracted domains array:', domains);
                        
                        if (Array.isArray(domains) && domains.length > 0) {
                            // Find .skr domain (check both with and without TLD)
                            const skrDomain = domains.find(d => {
                                if (!d || typeof d !== 'string') return false;
                                return d.endsWith('.skr') || d.includes('.skr');
                            });
                            
                            if (skrDomain) {
                                // Ensure it has .skr TLD
                                const finalDomain = skrDomain.endsWith('.skr') ? skrDomain : skrDomain + '.skr';
                                console.log('[SNS Lookup] ‚úÖ Returning .skr domain from SNS API v2:', finalDomain);
                                return finalDomain;
                            }
                            
                            console.log('[SNS Lookup] Found domains but none are .skr:', domains);
                        } else {
                            console.log('[SNS Lookup] No domains found in response (empty array or no domains registered)');
                        }
                    } else {
                        const errorText = await snsApiResponse.text().catch(() => '');
                        console.log('[SNS Lookup] SNS API v2 error:', snsApiResponse.status, errorText);
                    }
                } catch (snsApiError) {
                    console.log('[SNS Lookup] SNS API v2 exception:', snsApiError.message);
                }
                
                // Try QuickNode SNS API if endpoint is configured
                if (QUICKNODE_ENDPOINT && window.solanaWeb3) {
                    try {
                        console.log('[SNS Lookup] Trying QuickNode SNS API...');
                        const connection = new window.solanaWeb3.Connection(QUICKNODE_ENDPOINT, 'confirmed');
                        const walletPubkey = new window.solanaWeb3.PublicKey(walletAddress);
                        console.log('[SNS Lookup] Wallet PublicKey created:', walletPubkey.toString());
                        
                        // Try using QuickNode's sns_reverseLookup RPC method
                        // Query for name accounts using getProgramAccounts with the SNS program
                        // But first, we need a valid program ID - let's try a different approach
                        // Use QuickNode's enhanced RPC to query for domains
                        console.log('[SNS Lookup] Note: QuickNode found token accounts, but domain lookup via program accounts requires valid program ID');
                        console.log('[SNS Lookup] For .skr domains, the SNS API v2 endpoint should be used instead');
                        
                    } catch (quickNodeError) {
                        console.log('[SNS Lookup] QuickNode API error:', quickNodeError.message);
                    }
                } else if (!QUICKNODE_ENDPOINT) {
                    console.log('[SNS Lookup] QuickNode endpoint not configured. Set QUICKNODE_ENDPOINT to use QuickNode API.');
                }
                
                // Try API endpoints first (fastest)
                const apiEndpoints = [
                    `https://api.sns.id/v1/reverse-lookup/${walletAddress}`,
                    `https://api.sns.id/v1/wallet/${walletAddress}/domains`,
                    `https://api.sns.id/reverse-lookup/${walletAddress}`
                ];
                
                for (const endpoint of apiEndpoints) {
                    try {
                        console.log('[SNS Lookup] Trying API:', endpoint);
                        const apiResponse = await fetch(endpoint, {
                            method: 'GET',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        console.log('[SNS Lookup] API response status:', apiResponse.status);
                        
                        if (apiResponse.ok) {
                            const apiData = await apiResponse.json();
                            console.log('[SNS Lookup] API response data:', apiData);
                            
                            // Handle different response formats
                            let domain = null;
                            if (apiData && apiData.domain) {
                                domain = apiData.domain;
                            } else if (apiData && Array.isArray(apiData) && apiData.length > 0) {
                                domain = apiData.find(d => d && d.endsWith && d.endsWith('.skr')) || 
                                         apiData.find(d => d && d.name && d.name.endsWith('.skr'))?.name;
                            } else if (apiData && apiData.domains && Array.isArray(apiData.domains)) {
                                domain = apiData.domains.find(d => d && d.endsWith && d.endsWith('.skr'));
                            } else if (apiData && apiData.name) {
                                domain = apiData.name;
                            }
                            
                            console.log('[SNS Lookup] Found domain:', domain);
                            if (domain && typeof domain === 'string' && domain.endsWith('.skr')) {
                                console.log('[SNS Lookup] ‚úÖ Returning .skr domain:', domain);
                                return domain;
                            }
                        } else {
                            console.log('[SNS Lookup] API error:', apiResponse.status, await apiResponse.text().catch(() => ''));
                        }
                    } catch (apiError) {
                        console.log('[SNS Lookup] API exception:', apiError.message);
                        continue;
                    }
                }
                
                // Fallback: Use on-chain query
                // Use window.solanaWeb3 (same as used elsewhere in the code)
                if (window.solanaWeb3 && window.solanaWeb3.PublicKey && window.solanaWeb3.Connection) {
                    console.log('[SNS Lookup] Trying on-chain query...');
                    try {
                        // Validate wallet address format
                        if (!walletAddress || typeof walletAddress !== 'string') {
                            throw new Error('Invalid wallet address: not a string');
                        }
                        if (walletAddress.length < 32 || walletAddress.length > 44) {
                            throw new Error(`Invalid wallet address length: ${walletAddress.length}`);
                        }
                        
                        const connection = new window.solanaWeb3.Connection(
                            'https://api.mainnet-beta.solana.com',
                            { commitment: 'confirmed' }
                        );
                        
                        console.log('[SNS Lookup] Creating PublicKey from:', walletAddress);
                        const walletPubkey = new window.solanaWeb3.PublicKey(walletAddress);
                        console.log('[SNS Lookup] Created PublicKey:', walletPubkey.toString());
                        
                        // Note: The on-chain query approach may not work for .skr domains
                        // .skr domains might use a different program or lookup method
                        // Since API endpoints returned 404, the wallet likely doesn't have a .skr domain
                        // or we need to use a different API endpoint
                        console.log('[SNS Lookup] On-chain query not implemented for .skr domains');
                        console.log('[SNS Lookup] If you have a .skr domain, please check:');
                        console.log('[SNS Lookup] 1. The domain is properly linked to your wallet');
                        console.log('[SNS Lookup] 2. The correct API endpoint for .skr domain lookup');
                        // Don't throw error, just skip to fallback
                        return null;
                        
                        // Get all name accounts owned by this wallet
                        console.log('[SNS Lookup] Converting walletPubkey to bytes...');
                        const walletBytes = walletPubkey.toBytes();
                        console.log('[SNS Lookup] Wallet bytes length:', walletBytes.length);
                        
                        console.log('[SNS Lookup] Querying program accounts...');
                        const nameAccounts = await connection.getProgramAccounts(NAME_PROGRAM_ID, {
                            filters: [
                                {
                                    memcmp: {
                                        offset: 32, // Owner field offset in NameRecordHeader
                                        bytes: walletBytes
                                    }
                                }
                            ]
                        });
                        
                        console.log('[SNS Lookup] Found', nameAccounts.length, 'name accounts');
                        
                        // Try using Bonfida SDK reverseLookup if available
                        // Check multiple possible global names
                        const bonfidaSDK = window.Bonfida || window.bonfida || window.SPLNameService;
                        if (bonfidaSDK && bonfidaSDK.reverseLookup) {
                            console.log('[SNS Lookup] Using Bonfida SDK...');
                            for (const { pubkey } of nameAccounts) {
                                try {
                                    const domainName = await bonfidaSDK.reverseLookup(connection, pubkey);
                                    console.log('[SNS Lookup] Bonfida reverseLookup result:', domainName);
                                    if (domainName && domainName.endsWith('.skr')) {
                                        console.log('[SNS Lookup] ‚úÖ Returning .skr domain from SDK:', domainName);
                                        return domainName;
                                    }
                                } catch (e) {
                                    console.log('[SNS Lookup] Bonfida SDK error:', e.message);
                                    continue;
                                }
                            }
                        } else {
                            console.log('[SNS Lookup] Bonfida SDK not found, trying direct parsing...');
                        }
                    
                        // Fallback: Parse domain names directly from account data
                        for (const { account, pubkey } of nameAccounts) {
                            try {
                                if (!account.data || account.data.length < 100) continue;
                                
                                // NameRecordHeader is 96 bytes, domain name starts after that
                                const nameData = account.data.slice(96);
                                const nullIndex = nameData.findIndex(byte => byte === 0);
                                
                                if (nullIndex > 0) {
                                    const nameBytes = nameData.slice(0, nullIndex);
                                    const domainName = new TextDecoder('utf-8').decode(nameBytes).trim();
                                    console.log('[SNS Lookup] Parsed domain:', domainName);
                                
                                    if (domainName && domainName.endsWith('.skr')) {
                                        console.log('[SNS Lookup] ‚úÖ Returning .skr domain from parsing:', domainName);
                                        return domainName;
                                    }
                                }
                            } catch (parseError) {
                                console.log('[SNS Lookup] Parse error:', parseError.message);
                                continue;
                            }
                        }
                    } catch (onChainError) {
                        console.error('[SNS Lookup] On-chain query error:', onChainError.message, onChainError);
                    }
                } else {
                    console.log('[SNS Lookup] window.solanaWeb3 not available. Available:', {
                        windowSolanaWeb3: !!window.solanaWeb3,
                        hasPublicKey: !!(window.solanaWeb3 && window.solanaWeb3.PublicKey),
                        hasConnection: !!(window.solanaWeb3 && window.solanaWeb3.Connection)
                    });
                }
            } catch (error) {
                console.error('[SNS Lookup] ‚ùå Error:', error);
            }
            
            console.log('[SNS Lookup] ‚ö†Ô∏è No .skr domain found, using fallback');
            // Fallback to shortened wallet address
            return `${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`;
        }

        function SnakeGame() {
            const [screen, setScreen] = useState('menu');
            const [snake, setSnake] = useState(INITIAL_SNAKE);
            const [direction, setDirection] = useState(INITIAL_DIRECTION);
            const [food, setFood] = useState({x: 15, y: 15});
            const [foodEaten, setFoodEaten] = useState(0);
            const [highScore, setHighScore] = useState(() => {
                const saved = localStorage.getItem('snakeHighScore');
                if (!saved) return 0;
                const n = parseInt(saved, 10);
                return n >= 10 ? Math.round(n / 10) : n;
            });
            const [obstacles, setObstacles] = useState([]);
            const [speedBoost, setSpeedBoost] = useState(false);
            const [timer, setTimer] = useState(60);
            
            const [settings, setSettings] = useState({
                sound: true,
                vibration: true,
                difficulty: 'medium',
                gameMode: 'classic'
            });

            const [wallet, setWallet] = useState(null);
            const [snsName, setSnsName] = useState(null);
            const [leaderboard, setLeaderboard] = useState([]);
            const [leaderboardFilter, setLeaderboardFilter] = useState({ mode: 'classic', difficulty: 'medium' });
            const [submittingScore, setSubmittingScore] = useState(false);
            const [loadingLeaderboard, setLoadingLeaderboard] = useState(false);

            const canvasRef = useRef(null);
            const gameLoopRef = useRef(null);
            const directionRef = useRef(INITIAL_DIRECTION);
            const snakeRef = useRef(INITIAL_SNAKE);
            const gameSessionRef = useRef({ gameMode: 'classic', difficulty: 'medium' });

            const GAME_SPEEDS = { easy: 200, medium: 150, hard: 100 };

            // Load leaderboard from Supabase
            const loadLeaderboard = async () => {
                try {
                    setLoadingLeaderboard(true);
                    
                    // Get best score per wallet for this mode/difficulty
                    const { data, error } = await supabase
                        .rpc('get_best_scores', {
                            p_game_mode: leaderboardFilter.mode,
                            p_difficulty: leaderboardFilter.difficulty
                        });

                    if (error) {
                        // Fallback if RPC doesn't exist - get all and dedupe client-side
                        const { data: allData, error: fallbackError } = await supabase
                            .from('leaderboards')
                            .select('*')
                            .eq('game_mode', leaderboardFilter.mode)
                            .eq('difficulty', leaderboardFilter.difficulty)
                            .order('score', { ascending: false });

                        if (fallbackError) throw fallbackError;

                        // Keep only best score per wallet
                        const bestScores = {};
                        allData.forEach(entry => {
                            if (!bestScores[entry.wallet_address] || entry.score > bestScores[entry.wallet_address].score) {
                                bestScores[entry.wallet_address] = entry;
                            }
                        });

                        const toApples = (s) => (s >= 10 ? Math.round(Number(s) / 10) : Number(s));
                        const formatted = Object.values(bestScores)
                            .sort((a, b) => toApples(b.score) - toApples(a.score))
                            .slice(0, 100)
                            .map((entry, idx) => ({
                                rank: idx + 1,
                                name: entry.skr_name || `${entry.wallet_address.slice(0, 4)}...${entry.wallet_address.slice(-4)}`,
                                score: toApples(entry.score),
                                wallet: entry.wallet_address
                            }));

                        setLeaderboard(formatted);
                    } else {
                        const toApples = (s) => (s >= 10 ? Math.round(Number(s) / 10) : Number(s));
                        const formatted = data
                            .sort((a, b) => toApples(b.best_score || 0) - toApples(a.best_score || 0))
                            .slice(0, 100)
                            .map((entry, idx) => ({
                                rank: idx + 1,
                                name: entry.skr_name || `${entry.wallet_address.slice(0, 4)}...${entry.wallet_address.slice(-4)}`,
                                score: toApples(entry.best_score),
                                wallet: entry.wallet_address
                            }));
                        setLeaderboard(formatted);
                    }
                } catch (err) {
                    console.error('Failed to load leaderboard:', err);
                } finally {
                    setLoadingLeaderboard(false);
                }
            };

            useEffect(() => {
                loadLeaderboard();
            }, [leaderboardFilter]);

            const connectWallet = async () => {
                try {
                    if (!window.solana?.isPhantom) {
                        alert('Please install Phantom wallet from phantom.app');
                        window.open('https://phantom.app/', '_blank');
                        return;
                    }

                    const response = await window.solana.connect();
                    const pubkey = response.publicKey.toString();
                    
                    setWallet(pubkey);
                    const displayName = await getDisplayName(pubkey);
                    setSnsName(displayName);
                    
                    console.log('‚úÖ Wallet connected:', displayName);
                } catch (err) {
                    console.error('Connection error:', err);
                    alert('Connection failed: ' + err.message);
                }
            };

            const disconnectWallet = () => {
                if (window.solana) {
                    window.solana.disconnect();
                    setWallet(null);
                    setSnsName(null);
                }
            };

            const generateFood = useCallback(() => {
                let newFood;
                let attempts = 0;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * GRID_SIZE),
                        y: Math.floor(Math.random() * GRID_SIZE)
                    };
                    attempts++;
                } while (
                    attempts < 100 &&
                    (obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y) ||
                     snake.some(seg => seg.x === newFood.x && seg.y === newFood.y))
                );
                return newFood;
            }, [obstacles, snake]);

            const generateObstacles = useCallback(() => {
                const numObstacles = settings.gameMode === 'walls' ? 10 : 0;
                const newObstacles = [];
                for (let i = 0; i < numObstacles; i++) {
                    let obstacle;
                    let attempts = 0;
                    do {
                        obstacle = {
                            x: Math.floor(Math.random() * GRID_SIZE),
                            y: Math.floor(Math.random() * GRID_SIZE)
                        };
                        attempts++;
                    } while (
                        attempts < 100 &&
                        (newObstacles.some(obs => obs.x === obstacle.x && obs.y === obstacle.y) ||
                         INITIAL_SNAKE.some(seg => seg.x === obstacle.x && seg.y === obstacle.y) ||
                         (obstacle.x === 15 && obstacle.y === 15))
                    );
                    newObstacles.push(obstacle);
                }
                return newObstacles;
            }, [settings.gameMode]);

            const vibrate = (pattern) => {
                if (settings.vibration && navigator.vibrate) {
                    navigator.vibrate(pattern);
                }
            };

            const handleDirectionChange = (newDirection) => {
                if (screen !== 'playing') return;
                const currentDir = directionRef.current;
                if (newDirection.x === -currentDir.x && newDirection.y === -currentDir.y) return;
                directionRef.current = newDirection;
                setDirection(newDirection);
                vibrate(10);
            };

            const startGame = () => {
                gameSessionRef.current = { gameMode: settings.gameMode, difficulty: settings.difficulty };
                setSnake(INITIAL_SNAKE);
                snakeRef.current = INITIAL_SNAKE;
                setDirection(INITIAL_DIRECTION);
                directionRef.current = INITIAL_DIRECTION;
                setFood(generateFood());
                setFoodEaten(0);
                setSpeedBoost(false);
                setTimer(60);
                
                if (settings.gameMode === 'walls') {
                    setObstacles(generateObstacles());
                } else {
                    setObstacles([]);
                }
                
                setScreen('playing');
            };

            const submitScore = async (finalFoodCount) => {
                const apples = finalFoodCount;
                const session = gameSessionRef.current;
                if (wallet && apples > highScore) {
                    setHighScore(apples);
                    localStorage.setItem('snakeHighScore', String(apples));
                }
                if (apples === 0) return;
                if (!wallet) {
                    console.log('No wallet connected ‚Äì score not saved to leaderboard');
                    return;
                }
                setSubmittingScore(true);
                try {
                    const { error } = await supabase
                        .from('leaderboards')
                        .insert({
                            wallet_address: wallet,
                            skr_name: snsName,
                            score: apples,
                            game_mode: session.gameMode,
                            difficulty: session.difficulty
                        });

                    if (error) throw error;

                    console.log('Score submitted successfully!', session.gameMode, session.difficulty, apples);
                    setLeaderboardFilter({ mode: session.gameMode, difficulty: session.difficulty });
                } catch (err) {
                    console.error('Failed to submit score:', err);
                    alert('Could not save score to leaderboard. Try again.');
                } finally {
                    setSubmittingScore(false);
                }
            };

            const checkCollision = useCallback((head) => {
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    if (settings.gameMode !== 'portal') return true;
                }
                if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) return true;
                return false;
            }, [obstacles, settings.gameMode]);

            const gameLoop = useCallback(() => {
                const body = snakeRef.current;
                if (!body || body.length === 0) return;
                
                let head = {
                    x: body[0].x + directionRef.current.x,
                    y: body[0].y + directionRef.current.y
                };

                if (settings.gameMode === 'portal') {
                    if (head.x < 0) head.x = GRID_SIZE - 1;
                    if (head.x >= GRID_SIZE) head.x = 0;
                    if (head.y < 0) head.y = GRID_SIZE - 1;
                    if (head.y >= GRID_SIZE) head.y = 0;
                }

                // Self-collision: check new head against ALL body segments
                // This works for ALL game modes including portal
                for (let i = 0; i < body.length; i++) {
                    if (head.x === body[i].x && head.y === body[i].y) {
                        if (gameLoopRef.current) {
                            clearInterval(gameLoopRef.current);
                            gameLoopRef.current = null;
                        }
                        setScreen('gameOver');
                        submitScore(foodEaten);
                        if (settings.sound) playSound(100, 0.3, 0.3);
                        vibrate([200, 100, 200]);
                        return;
                    }
                }
                if (checkCollision(head)) {
                    if (gameLoopRef.current) {
                        clearInterval(gameLoopRef.current);
                        gameLoopRef.current = null;
                    }
                    setScreen('gameOver');
                    submitScore(foodEaten);
                    if (settings.sound) playSound(100, 0.3, 0.3);
                    vibrate([200, 100, 200]);
                    return;
                }

                let newSnake = [head, ...body];

                if (head.x === food.x && head.y === food.y) {
                    setFoodEaten(f => f + 1);
                    setFood(generateFood());
                    if (settings.sound) playSound(800, 0.1, 0.2);
                    vibrate(50);
                    if (settings.gameMode === 'speed') {
                        setSpeedBoost(true);
                        setTimeout(() => setSpeedBoost(false), 3000);
                    }
                } else {
                    newSnake.pop();
                }

                snakeRef.current = newSnake;
                setSnake(newSnake);
            }, [food, checkCollision, foodEaten, generateFood, settings.sound, settings.vibration, settings.gameMode]);

            useEffect(() => {
                if (screen === 'playing') {
                    let speed = GAME_SPEEDS[settings.difficulty];
                    if (settings.gameMode === 'speed' && speedBoost) {
                        speed = Math.max(speed - 50, 50);
                    }
                    gameLoopRef.current = setInterval(gameLoop, speed);
                    return () => clearInterval(gameLoopRef.current);
                }
            }, [screen, gameLoop, settings.difficulty, settings.gameMode, speedBoost]);

            useEffect(() => {
                if (screen === 'playing' && settings.gameMode === 'survival') {
                    const timerInterval = setInterval(() => {
                        setTimer(t => {
                            if (t <= 1) {
                                setScreen('gameOver');
                                submitScore(foodEaten);
                                return 0;
                            }
                            return t - 1;
                        });
                    }, 1000);
                    return () => clearInterval(timerInterval);
                }
            }, [screen, settings.gameMode, foodEaten]);

            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (screen === 'playing') {
                        const currentDir = directionRef.current;
                        if (e.key === 'ArrowUp' && currentDir.y === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 0, y: -1});
                        } else if (e.key === 'ArrowDown' && currentDir.y === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 0, y: 1});
                        } else if (e.key === 'ArrowLeft' && currentDir.x === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: -1, y: 0});
                        } else if (e.key === 'ArrowRight' && currentDir.x === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 1, y: 0});
                        } else if (e.key === 'Escape' || e.key === ' ') {
                            e.preventDefault();
                            setScreen('paused');
                        }
                    } else if (screen === 'paused' && (e.key === 'Escape' || e.key === ' ')) {
                        e.preventDefault();
                        setScreen('playing');
                    }
                };
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [screen]);

            useEffect(() => {
                if (screen !== 'playing') return;
                let touchStartX = 0, touchStartY = 0;
                const handleTouchStart = (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                };
                const handleTouchEnd = (e) => {
                    const deltaX = e.changedTouches[0].screenX - touchStartX;
                    const deltaY = e.changedTouches[0].screenY - touchStartY;
                    if (Math.abs(deltaX) < 30 && Math.abs(deltaY) < 30) return;
                    const currentDir = directionRef.current;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0 && currentDir.x === 0) handleDirectionChange({x: 1, y: 0});
                        else if (deltaX < 0 && currentDir.x === 0) handleDirectionChange({x: -1, y: 0});
                    } else {
                        if (deltaY > 0 && currentDir.y === 0) handleDirectionChange({x: 0, y: 1});
                        else if (deltaY < 0 && currentDir.y === 0) handleDirectionChange({x: 0, y: -1});
                    }
                };
                window.addEventListener('touchstart', handleTouchStart, {passive: true});
                window.addEventListener('touchend', handleTouchEnd, {passive: true});
                return () => {
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchend', handleTouchEnd);
                };
            }, [screen]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (obstacles.length > 0) {
                    ctx.fillStyle = '#1a1a1a';
                    obstacles.forEach(obs => {
                        ctx.fillRect(obs.x * CELL_SIZE, obs.y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1);
                    });
                }

                ctx.fillStyle = speedBoost ? '#FFD700' : '#14F195';
                snake.forEach((segment) => {
                    ctx.fillRect(segment.x * CELL_SIZE + 1, segment.y * CELL_SIZE + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                });

                ctx.fillStyle = '#9945FF';
                ctx.beginPath();
                ctx.arc(
                    food.x * CELL_SIZE + CELL_SIZE / 2,
                    food.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE / 2 - 2, 0, Math.PI * 2
                );
                ctx.fill();
            }, [snake, food, obstacles, speedBoost]);

            if (screen === 'menu') {
                return (
                    <div className="fullscreen">
                        <div className="menu-container">
                            <div className="logo-big">
                                <span className="logo-accent">‚ó¢</span> SNAKE
                            </div>
                            <div className="tagline">SOLANA SEEKER</div>
                            
                            <button className="menu-button" onClick={startGame}>
                                START GAME
                            </button>
                            <button className="menu-button secondary" onClick={() => setScreen('settings')}>
                                SETTINGS
                            </button>
                            <button className="menu-button secondary" onClick={() => setScreen('leaderboard')}>
                                LEADERBOARD
                            </button>
                            {!wallet ? (
                                <button className="menu-button secondary" onClick={connectWallet}>
                                    CONNECT WALLET
                                </button>
                            ) : (
                                <button className="menu-button secondary" onClick={disconnectWallet}>
                                    DISCONNECT
                                </button>
                            )}

                            {wallet && (
                                <div className="wallet-display">
                                    {snsName || '...loading'}
                                </div>
                            )}
                        </div>
                    </div>
                );
            }

            if (screen === 'settings') {
                return (
                    <div className="fullscreen">
                        <div className="settings-container">
                            <div className="settings-title">SETTINGS</div>
                            
                            <div className="setting-row">
                                <div className="setting-name">Sound</div>
                                <div 
                                    className={`toggle ${settings.sound ? 'active' : ''}`}
                                    onClick={() => setSettings({...settings, sound: !settings.sound})}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Vibration</div>
                                <div 
                                    className={`toggle ${settings.vibration ? 'active' : ''}`}
                                    onClick={() => setSettings({...settings, vibration: !settings.vibration})}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Difficulty</div>
                                <select 
                                    className="select-box"
                                    value={settings.difficulty}
                                    onChange={(e) => setSettings({...settings, difficulty: e.target.value})}
                                >
                                    <option value="easy">Easy</option>
                                    <option value="medium">Medium</option>
                                    <option value="hard">Hard</option>
                                </select>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Game Mode</div>
                                <select 
                                    className="select-box"
                                    value={settings.gameMode}
                                    onChange={(e) => setSettings({...settings, gameMode: e.target.value})}
                                >
                                    <option value="classic">Classic</option>
                                    <option value="walls">Walls</option>
                                    <option value="portal">Portal</option>
                                    <option value="speed">Speed</option>
                                    <option value="survival">Survival</option>
                                </select>
                            </div>

                            <button className="menu-button" style={{marginTop: '40px'}} onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            if (screen === 'leaderboard') {
                return (
                    <div className="fullscreen">
                        <div className="leaderboard-container">
                            <div className="leaderboard-title">LEADERBOARD</div>
                            <div className="leaderboard-subtitle">
                                {leaderboardFilter.mode.toUpperCase()} ‚Ä¢ {leaderboardFilter.difficulty.toUpperCase()}
                            </div>
                            <p style={{ fontSize: '0.85em', color: '#888', marginTop: 4, marginBottom: 8 }}>
                                Separate board for each game mode and difficulty.
                            </p>
                            <div className="leaderboard-filters">
                                <select 
                                    className="filter-select"
                                    value={leaderboardFilter.mode}
                                    onChange={(e) => setLeaderboardFilter({...leaderboardFilter, mode: e.target.value})}
                                >
                                    <option value="classic">Classic</option>
                                    <option value="walls">Walls</option>
                                    <option value="portal">Portal</option>
                                    <option value="speed">Speed</option>
                                    <option value="survival">Survival</option>
                                </select>
                                
                                <select 
                                    className="filter-select"
                                    value={leaderboardFilter.difficulty}
                                    onChange={(e) => setLeaderboardFilter({...leaderboardFilter, difficulty: e.target.value})}
                                >
                                    <option value="easy">Easy</option>
                                    <option value="medium">Medium</option>
                                    <option value="hard">Hard</option>
                                </select>
                            </div>
                            
                            <div key={`lb-${leaderboardFilter.mode}-${leaderboardFilter.difficulty}`} className="leaderboard-list">
                                {loadingLeaderboard ? (
                                    <div style={{textAlign: 'center', color: '#666', padding: '40px 20px'}}>
                                        Loading...
                                    </div>
                                ) : leaderboard.length === 0 ? (
                                    <div style={{textAlign: 'center', color: '#666', padding: '40px 20px', fontSize: '1.1em'}}>
                                        No scores yet.<br/>
                                        Be the first!
                                    </div>
                                ) : (
                                    leaderboard.map((entry) => (
                                        <div key={`${entry.rank}-${entry.wallet}`} className="leaderboard-entry">
                                            <div className="entry-rank">#{entry.rank}</div>
                                            <div className="entry-name">{entry.name}</div>
                                            <div className="entry-score">{entry.score} üçé</div>
                                        </div>
                                    ))
                                )}
                            </div>

                            <button className="menu-button" onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="fullscreen">
                    <div className="game-screen">
                        <div className="game-hud">
                            <div className="hud-left">
                                <div className="stat-pill">
                                    <span className="label">SCORE</span>
                                    {foodEaten}
                                </div>
                                <div className="stat-pill">
                                    <span className="label">HIGH SCORE</span>
                                    {highScore}
                                </div>
                                {settings.gameMode === 'survival' && (
                                    <div className="stat-pill">
                                        <span className="label">TIME</span>
                                        {timer}s
                                    </div>
                                )}
                            </div>
                            {screen === 'playing' && (
                                <button className="pause-btn" onClick={() => setScreen('paused')}>
                                    PAUSE
                                </button>
                            )}
                        </div>

                        <canvas
                            ref={canvasRef}
                            width={GRID_SIZE * CELL_SIZE}
                            height={GRID_SIZE * CELL_SIZE}
                        />

                        {screen === 'paused' && (
                            <div className="overlay">
                                <div className="overlay-title">PAUSED</div>
                                <div className="overlay-buttons">
                                    <button className="overlay-button" onClick={() => setScreen('playing')}>
                                        RESUME
                                    </button>
                                    <button className="overlay-button secondary" onClick={() => setScreen('menu')}>
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}

                        {screen === 'gameOver' && (
                            <div className="overlay">
                                <div className="overlay-title">GAME OVER</div>
                                <div className="overlay-score">
                                    FINAL SCORE
                                    <span>{foodEaten}</span>
                                </div>
                                {submittingScore && (
                                    <div className="loading-message">
                                        Submitting score...
                                    </div>
                                )}
                                {!wallet && !submittingScore && (
                                    <div style={{ fontSize: '0.9em', color: '#888', marginTop: 8 }}>
                                        Connect wallet to save your score to the leaderboard.
                                    </div>
                                )}
                                <div className="overlay-buttons">
                                    <button 
                                        className="overlay-button" 
                                        onClick={startGame}
                                        disabled={submittingScore}
                                    >
                                        PLAY AGAIN
                                    </button>
                                    <button 
                                        className="overlay-button secondary" 
                                        onClick={() => setScreen('menu')}
                                        disabled={submittingScore}
                                    >
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<SnakeGame />, document.getElementById('root'));
    </script>
</body>
</html>
