<!DOCTYPE html>
<html lang="en">
<head>
    <!-- CRITICAL: Load these FIRST before any other scripts -->
    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@onsol/tldparser@0.5.2/lib/index.iife.js"></script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Snake">
    <title>Snake - Solana</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon.svg">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@bonfida/spl-name-service@2.1.0/dist/index.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Mobile Wallet Adapter (Seeker / Seed Vault) - bundled for WebView/Expo -->
    <script src="mwa-bundle.js"></script>
    <script>
        if (typeof window.__snakeWalletAdapter === 'undefined') {
            window.__snakeWalletAdapter = { ready: false, connect: null, disconnect: null };
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root, [data-theme="dark"] {
            --bg: #000;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #222;
            --text: #fff;
            --text-muted: #666;
            --text-dim: #999;
            --accent: #14F195;
            --border: #2a2a2a;
            --canvas-bg: #000;
            --obstacle-bg: #1a1a1a;
            --overlay-bg: rgba(0,0,0,0.8);
            --pill-bg: rgba(0,0,0,0.8);
            --button-primary-bg: #fff;
            --button-primary-text: #000;
            --button-secondary-bg: #1a1a1a;
            --button-secondary-text: #fff;
            --toggle-inactive: #666;
            --skin-active-border: #fff;
            --level-locked: #444;
        }
        [data-theme="light"] {
            --bg: #f5f5f5;
            --bg-secondary: #e8e8e8;
            --bg-tertiary: #ddd;
            --text: #1a1a1a;
            --text-muted: #555;
            --text-dim: #666;
            --accent: #0cb864;
            --border: #ccc;
            --canvas-bg: #e8e8e8;
            --obstacle-bg: #ccc;
            --overlay-bg: rgba(255,255,255,0.95);
            --pill-bg: rgba(255,255,255,0.9);
            --button-primary-bg: #1a1a1a;
            --button-primary-text: #fff;
            --button-secondary-bg: #fff;
            --button-secondary-text: #1a1a1a;
            --toggle-inactive: #bbb;
            --skin-active-border: #1a1a1a;
            --level-locked: #bbb;
        }
        body {
            font-family: 'Space Grotesk', monospace;
            background: var(--bg);
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text);
        }
        .fullscreen {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .menu-fullscreen {
            width: 100%;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px 16px;
            background: var(--bg);
            background-image: radial-gradient(ellipse 120% 80% at 50% 0%, var(--bg-secondary) 0%, transparent 55%),
                              radial-gradient(ellipse 80% 50% at 50% 100%, var(--bg-tertiary) 0%, transparent 50%);
        }
        .menu-container {
            width: 100%;
            max-width: 400px;
        }
        .menu-card {
            position: relative;
            overflow: hidden;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 40px 28px 32px;
            text-align: center;
            box-shadow: 0 4px 24px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.03) inset;
        }
        [data-theme="light"] .menu-card {
            box-shadow: 0 4px 24px rgba(0,0,0,0.08), 0 0 0 1px rgba(0,0,0,0.04) inset;
        }
        .menu-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent 0%, var(--accent) 50%, transparent 100%);
            border-radius: 20px 20px 0 0;
        }
        .menu-header {
            margin-bottom: 32px;
        }
        .logo-big {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 4px;
            letter-spacing: -1px;
            line-height: 1.15;
        }
        .logo-accent { color: var(--accent); }
        .menu-tagline {
            color: var(--text-muted);
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        .menu-primary {
            margin-bottom: 4px;
        }
        .menu-button {
            width: 100%;
            padding: 16px 24px;
            margin: 0 auto;
            display: block;
            background: var(--accent);
            color: #000;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            font-family: 'Space Grotesk';
            letter-spacing: 0.02em;
            box-shadow: 0 2px 12px rgba(20, 241, 149, 0.35);
        }
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(20, 241, 149, 0.4);
        }
        .menu-button:active {
            transform: translateY(0);
        }
        .menu-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .menu-divider {
            height: 1px;
            background: var(--border);
            margin: 20px 0 16px;
        }
        .menu-nav {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .menu-button.secondary {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            font-weight: 500;
            font-size: 0.9rem;
            padding: 12px 20px;
            box-shadow: none;
        }
        .menu-button.secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--text-muted);
            box-shadow: none;
        }
        .menu-wallet-wrap {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }
        .wallet-display {
            padding: 8px 16px;
            background: rgba(20, 241, 149, 0.1);
            border: 1px solid rgba(20, 241, 149, 0.35);
            border-radius: 999px;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--accent);
            display: inline-block;
        }
        .game-screen {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            touch-action: none;
            position: relative;
        }
        .game-canvas-wrap {
            position: relative;
            display: inline-block;
            line-height: 0;
        }
        .game-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        .hud-left { display: flex; gap: 15px; }
        .stat-pill {
            background: var(--pill-bg);
            border: 1px solid var(--border);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.95em;
            color: var(--accent);
            font-weight: 600;
        }
        .stat-pill .label {
            color: var(--text-muted);
            font-size: 0.8em;
            margin-right: 10px;
            text-transform: uppercase;
        }
        .pause-btn {
            background: var(--pill-bg);
            border: 1px solid var(--border);
            padding: 10px 20px;
            border-radius: 25px;
            color: var(--text);
            font-weight: 600;
            cursor: pointer;
            pointer-events: all;
            font-family: 'Space Grotesk';
            font-size: 0.9em;
        }
        .pause-btn:hover { background: var(--accent); color: #000; }
        canvas {
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--canvas-bg);
            box-shadow: 0 0 80px rgba(20, 241, 149, 0.2);
        }
        .overlay {
            position: absolute;
            inset: 0;
            background: var(--overlay-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 30px;
            z-index: 100;
        }
        .overlay-title {
            font-size: 4em;
            font-weight: 700;
            letter-spacing: -2px;
        }
        .overlay-score {
            font-size: 1.5em;
            color: var(--text-muted);
        }
        .overlay-score span {
            color: var(--accent);
            font-size: 2em;
            font-weight: 700;
            display: block;
            margin-top: 10px;
        }
        .overlay-buttons { display: flex; gap: 15px; }
        .overlay-button {
            padding: 18px 40px;
            background: var(--button-primary-bg);
            color: var(--button-primary-text);
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Space Grotesk';
            transition: all 0.2s;
        }
        .overlay-button:hover {
            background: var(--accent);
            color: #000;
            transform: translateY(-2px);
        }
        .overlay-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .overlay-button.secondary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #2a2a2a;
        }
        .overlay-button.secondary:hover { background: var(--bg-tertiary); }
        .settings-container {
            width: 100%;
            max-width: 500px;
            padding: 40px;
        }
        .settings-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 40px;
            text-align: center;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
        }
        .setting-name {
            font-size: 1.1em;
            font-weight: 500;
        }
        .toggle {
            width: 56px;
            height: 30px;
            background: var(--bg-secondary);
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
            border: 1px solid var(--border);
        }
        .toggle.active { background: var(--accent); }
        .toggle-knob {
            width: 24px;
            height: 24px;
            background: var(--toggle-inactive);
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }
        .toggle.active .toggle-knob {
            left: 28px;
            background: var(--button-primary-text);
        }
        .select-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 12px 20px;
            border-radius: 8px;
            color: var(--text);
            font-size: 1em;
            cursor: pointer;
            font-family: 'Space Grotesk';
            font-weight: 500;
            min-width: 140px;
        }
        .skin-swatches {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .skin-swatch {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            padding: 0;
            transition: transform 0.15s, border-color 0.15s;
        }
        .skin-swatch:hover {
            transform: scale(1.1);
        }
        .skin-swatch.active {
            border-color: var(--skin-active-border);
            box-shadow: 0 0 0 1px var(--border);
        }
        .leaderboard-container {
            width: 100%;
            max-width: 600px;
            padding: 40px;
        }
        .leaderboard-title {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }
        .leaderboard-subtitle {
            color: var(--text-muted);
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .leaderboard-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }
        .filter-select {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 10px 16px;
            border-radius: 6px;
            color: var(--text);
            font-size: 0.9em;
            cursor: pointer;
            font-family: 'Space Grotesk';
            font-weight: 500;
        }
        .leaderboard-list {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 30px;
        }
        .leaderboard-entry {
            display: flex;
            align-items: center;
            padding: 18px 0;
            border-bottom: 1px solid var(--border);
        }
        .entry-rank {
            width: 40px;
            font-weight: 700;
            color: #14F195;
            font-size: 1.1em;
        }
        .entry-name {
            flex: 1;
            font-size: 1.05em;
        }
        .entry-score {
            color: var(--text-muted);
            font-weight: 600;
            font-size: 1.05em;
        }
        .loading-message {
            color: #14F195;
            font-size: 0.9em;
            margin-top: 15px;
        }
        .play-select-container {
            width: 100%;
            max-width: 520px;
            padding: 24px;
        }
        .play-select-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 28px;
            flex-wrap: wrap;
            gap: 16px;
        }
        .play-select-title { font-size: 1.8em; font-weight: 700; }
        .play-select-difficulty {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .play-select-difficulty label { font-size: 0.9em; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .mode-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode-row:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }
        .mode-row .mode-name { font-weight: 600; font-size: 1.1em; }
        .mode-row .mode-desc { font-size: 0.8em; color: var(--text-muted); margin-top: 2px; }
        .mode-row select { margin-left: 12px; }
        .shop-fullscreen {
            width: 100%;
            min-height: 100vh;
            padding: 20px 16px 80px;
            background: var(--bg);
            background-image: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg) 25%, var(--bg) 100%);
        }
        .shop-container { width: 100%; max-width: 900px; margin: 0 auto; }
        .shop-header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            margin-bottom: 8px;
        }
        .shop-title {
            font-size: 1.75rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        .shop-balance-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: rgba(0,0,0,0.4);
            border: 1px solid var(--border);
            border-radius: 999px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text);
        }
        .shop-balance-pill .shop-currency-icon { font-size: 1.2em; }
        .shop-section-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: var(--text-muted);
            margin-bottom: 14px;
        }
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }
        @media (min-width: 520px) {
            .shop-grid { grid-template-columns: repeat(3, 1fr); gap: 20px; }
        }
        .shop-card {
            position: relative;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .shop-card:hover { transform: translateY(-2px); }
        .shop-card.owned { opacity: 0.85; }
        .shop-card.owned .shop-card-preview { filter: saturate(0.6); }
        .shop-card-rare { border-color: var(--shop-rarity-border); box-shadow: 0 0 20px var(--shop-rarity-glow); }
        .shop-card-rare:hover { box-shadow: 0 0 28px var(--shop-rarity-glow); }
        .shop-card-preview-wrap {
            padding: 20px 16px;
            min-height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
        }
        .shop-card-preview-wrap canvas { border-radius: 12px; }
        .shop-skin-preview-wrap {
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .shop-card-body {
            padding: 14px 16px 16px;
            border-top: 1px solid var(--border);
        }
        .shop-card-rarity {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 4px;
        }
        .shop-card-name { font-size: 1.05rem; font-weight: 700; margin-bottom: 10px; }
        .shop-card-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        .shop-card-price {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text);
        }
        .shop-card-price .shop-currency-icon { font-size: 1.1em; }
        .shop-card-buy {
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            font-family: 'Space Grotesk';
            background: var(--accent);
            color: #000;
            transition: transform 0.1s, box-shadow 0.15s;
        }
        .shop-card-buy:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 14px rgba(20, 241, 149, 0.4);
        }
        .shop-card-buy:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .shop-owned-badge {
            padding: 8px 14px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 600;
            background: var(--bg-tertiary);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }
        .shop-back-wrap { margin-top: 28px; text-align: center; }
        .shop-back-wrap .menu-button.secondary { max-width: 200px; }
        [data-theme="light"] .shop-balance-pill {
            background: rgba(255,255,255,0.8);
            border-color: var(--border);
        }
        [data-theme="light"] .shop-card-preview-wrap {
            background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
        }
        .levels-container {
            width: 100%;
            max-width: 520px;
            padding: 24px;
        }
        .levels-title { font-size: 1.8em; margin-bottom: 8px; }
        .levels-subtitle { color: var(--text-muted); font-size: 0.9em; margin-bottom: 24px; }
        .levels-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 28px;
        }
        .level-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .level-card:hover:not(.locked) { border-color: var(--accent); background: var(--bg-tertiary); }
        .level-card.locked { opacity: 0.5; cursor: not-allowed; }
        .level-card .level-num { font-size: 1.1em; font-weight: 700; color: #14F195; margin-bottom: 4px; }
        .level-card .level-name { font-size: 0.7em; color: #999; line-height: 1.2; margin-bottom: 6px; }
        .level-stars { font-size: 0.85em; color: #EAB308; letter-spacing: 1px; }
        .level-stars.empty { color: #444; }
        .level-complete-stars { font-size: 2em; color: #EAB308; margin: 12px 0; letter-spacing: 4px; }
        .io-leaderboard-hud {
            background: var(--pill-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 8px 12px;
            min-width: 120px;
        }
        .io-leaderboard-hud-title {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 6px;
        }
        .io-leaderboard-row, .io-leaderboard-final-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            padding: 2px 0;
        }
        .io-leaderboard-row.dead, .io-leaderboard-final-row.dead { opacity: 0.5; }
        .io-leaderboard-row.player .io-name, .io-leaderboard-final-row.player .io-name { font-weight: 700; color: var(--accent); }
        .io-rank { color: var(--text-muted); min-width: 22px; }
        .io-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .io-len { font-weight: 600; color: var(--accent); }
        .io-leaderboard-final {
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            min-width: 200px;
        }
        .io-leaderboard-final-title {
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 10px;
        }
        .joystick-wrap {
            position: relative;
            margin-top: 20px;
            width: 100px;
            height: 100px;
            flex-shrink: 0;
            touch-action: none;
            pointer-events: auto;
        }
        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .joystick-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid rgba(255,255,255,0.5);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: none;
            pointer-events: none;
        }
        .copyright-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            padding: 10px 14px;
            color: var(--text);
            font-size: 12px;
            font-family: 'Space Grotesk', monospace;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div class="copyright-footer">Â© solanasnake.com</div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const { Connection, PublicKey } = window.solanaWeb3;

        // Supabase credentials
        const SUPABASE_URL = 'https://aukbtnujqzilrqxgelxq.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImF1a2J0bnVqcXppbHJxeGdlbHhxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAxMTc1NjQsImV4cCI6MjA4NTY5MzU2NH0.PGwNORkCQn_EztvA4EKoWYQZ3xlhS1a9g-NGPSTL6d4';
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        
        const connection = new Connection('https://api.devnet.solana.com', 'confirmed');

        const GRID_SIZE = 20;
        const INITIAL_SNAKE = [{x: 10, y: 10}];
        const INITIAL_DIRECTION = {x: 1, y: 0};
        const GRID_SIZE_IO = 80;
        const VIEWPORT_CELLS = 27;
        const IO_NUM_APPLES = 20;
        const IO_AI_NAMES = ['Bot Red', 'Bot Blue', 'Bot Green', 'Bot Violet', 'Bot Orange'];
        const IO_SNAKE_COLORS = ['#14F195', '#EF4444', '#3B82F6', '#8B5CF6', '#F59E0B', '#EC4899'];
        const IO_DIRS = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
        const IO_FREE_SPEED = 5;
        const IO_EAT_RADIUS = 0.6;
        const IO_COLLIDE_RADIUS = 0.35;
        const IO_SEGMENT_RADIUS = 0.35;
        const IO_SELF_COLLIDE_MIN_DIST = 1.2;

        const SNAKE_SKINS = {
            blue: '#3B82F6',
            orange: '#F97316',
            yellow: '#EAB308',
            green: '#14F195',
            indigo: '#6366F1',
            violet: '#8B5CF6',
            cyan: '#22D3EE',
            pink: '#EC4899',
            lime: '#84CC16',
            coral: '#F43F5E',
            leopard: '#C19A6B',
            rainbow: '#FF0000',
            gold: '#D4AF37',
            crimson: '#DC2626',
            mint: '#2DD4BF',
            midnight: '#1E293B'
        };
        const ROYGBIV = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#8B00FF'];
        const SNAKE_SKIN_IDS = ['blue', 'orange', 'yellow', 'green', 'indigo', 'violet', 'cyan', 'pink', 'lime', 'coral'];
        const SHOP_RARITIES = {
            common: { label: 'Common', color: '#9ca3af', border: '#6b7280', glow: 'rgba(156,163,175,0.25)' },
            uncommon: { label: 'Uncommon', color: '#22c55e', border: '#16a34a', glow: 'rgba(34,197,94,0.3)' },
            rare: { label: 'Rare', color: '#3b82f6', border: '#2563eb', glow: 'rgba(59,130,246,0.35)' },
            epic: { label: 'Epic', color: '#a855f7', border: '#7c3aed', glow: 'rgba(168,85,247,0.4)' },
            legendary: { label: 'Legendary', color: '#f59e0b', border: '#d97706', glow: 'rgba(245,158,11,0.45)' }
        };
        const SHOP_SKINS = [
            { id: 'gold', price: 50, name: 'Gold', rarity: 'legendary' },
            { id: 'crimson', price: 75, name: 'Crimson', rarity: 'epic' },
            { id: 'mint', price: 75, name: 'Mint', rarity: 'epic' },
            { id: 'leopard', price: 100, name: 'Leopard', rarity: 'rare' },
            { id: 'midnight', price: 150, name: 'Midnight', rarity: 'epic' },
            { id: 'rainbow', price: 200, name: 'Rainbow', rarity: 'legendary' }
        ];
        const APPLE_COINS_KEY = 'snakeAppleCoins';
        const UNLOCKED_SKINS_KEY = 'snakeUnlockedSkins';

        function ShopSnakePreview({ skinId, size }) {
            const canvasRef = React.useRef(null);
            const isLarge = size === 'large';
            React.useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const cellSize = isLarge ? 28 : 22;
                const segCount = 6;
                const pad = isLarge ? 18 : 14;
                const w = segCount * cellSize + pad * 2;
                const h = cellSize + pad * 2;
                const dpr = window.devicePixelRatio || 1;
                canvas.width = w * dpr;
                canvas.height = h * dpr;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                const bg = document.documentElement.getAttribute('data-theme') === 'light' ? '#e0e0e0' : '#1a1a1a';
                ctx.fillStyle = bg;
                ctx.beginPath();
                if (ctx.roundRect) ctx.roundRect(0, 0, w, h, 10);
                else { ctx.rect(0, 0, w, h); }
                ctx.fill();
                const isRainbow = skinId === 'rainbow';
                const isGold = skinId === 'gold';
                const segW = cellSize - 2;
                for (let i = 0; i < segCount; i++) {
                    const x = pad + i * cellSize + 1;
                    const y = pad + 1;
                    if (isRainbow) {
                        ctx.fillStyle = ROYGBIV[i % 7];
                    } else if (isGold) {
                        const g = ctx.createLinearGradient(x, y, x + segW, y + segW);
                        g.addColorStop(0, '#F7E7CE');
                        g.addColorStop(0.35, '#E8C547');
                        g.addColorStop(0.7, '#B8860B');
                        g.addColorStop(1, '#8B6914');
                        ctx.fillStyle = g;
                    } else {
                        ctx.fillStyle = SNAKE_SKINS[skinId] || '#14F195';
                    }
                    ctx.fillRect(x, y, segW, segW);
                }
                if (skinId === 'leopard') {
                    ctx.fillStyle = '#4a3728';
                    const spotSize = 3;
                    const spots = [
                        [pad + 1 * cellSize + 5, pad + 5],
                        [pad + 1 * cellSize + 14, pad + 14],
                        [pad + 2 * cellSize + 7, pad + 10],
                        [pad + 3 * cellSize + 11, pad + 8],
                        [pad + 4 * cellSize + 6, pad + 12],
                        [pad + 5 * cellSize + 9, pad + 6]
                    ];
                    spots.forEach(([sx, sy]) => ctx.fillRect(sx, sy, spotSize, spotSize));
                }
            }, [skinId, isLarge]);
            return <canvas ref={canvasRef} style={{ borderRadius: 10, display: 'block' }} />;
        }

        // Level mode: routing puzzles and distinct shapes, not just more blocks.
        // Each level has a clear idea: one gap, S-path, thread the needle, figure-8, etc.
        function _flatten(arr) {
            return arr.reduce(function(a, b) {
                if (!Array.isArray(b)) return a.concat([b]);
                if (b.length && typeof b[0]==='object' && b[0]!==null && 'x' in b[0]) return a.concat(b);
                return a.concat(_flatten(b));
            }, []);
        }
        function _obs() { var a=[]; for (var i=0;i<arguments.length;i+=2) a.push({x:arguments[i],y:arguments[i+1]}); return a; }
        const LEVELS = [
            { id: 1, name: 'First Bite', targetApples: 5, star3Time: 14, star2Time: 24, obstacles: (function(){ var o=[]; for(var x=0;x<=19;x++) if(x!==9&&x!==10) o.push({x:x,y:9}); return o; })() },
            { id: 2, name: 'Cornered', targetApples: 8, star3Time: 22, star2Time: 38, obstacles: _obs(0,0,1,0,0,1, 19,19,18,19,19,18, 0,19,1,19,0,18, 19,0,18,0,19,1) },
            { id: 3, name: 'The Gauntlet', targetApples: 10, star3Time: 30, star2Time: 52, obstacles: (function(){ var o=[]; for(var x=0;x<=8;x++) o.push({x:x,y:7},{x:x,y:12}); for(var x=11;x<=19;x++) o.push({x:x,y:7},{x:x,y:12}); for(var y=0;y<=6;y++) o.push({x:9,y:y},{x:10,y:y}); for(var y=13;y<=19;y++) o.push({x:9,y:y},{x:10,y:y}); return o; })() },
            { id: 4, name: 'Thread the Needle', targetApples: 12, star3Time: 40, star2Time: 65, obstacles: (function(){ var o=[]; for(var y=2;y<=17;y++) if(y!==9&&y!==10) o.push({x:7,y:y},{x:12,y:y}); for(var x=0;x<=6;x++) o.push({x:x,y:5},{x:x,y:14}); for(var x=13;x<=19;x++) o.push({x:x,y:5},{x:x,y:14}); return o; })() },
            { id: 5, name: 'Maze Runner', targetApples: 15, star3Time: 52, star2Time: 85, obstacles: (function(){ var o=[]; for(var x=1;x<=6;x++) o.push({x:x,y:4},{x:x,y:15}); for(var x=13;x<=18;x++) o.push({x:x,y:4},{x:x,y:15}); for(var y=4;y<=8;y++) o.push({x:8,y:y},{x:11,y:y}); for(var y=11;y<=15;y++) o.push({x:8,y:y},{x:11,y:y}); return o; })() },
            { id: 6, name: 'Split Lane', targetApples: 18, star3Time: 62, star2Time: 98, obstacles: (function(){ var o=[]; for(var x=0;x<=19;x++) if(x!==5&&x!==14) o.push({x:x,y:8},{x:x,y:11}); for(var y=0;y<=7;y++) o.push({x:6,y:y},{x:13,y:y}); for(var y=12;y<=19;y++) o.push({x:6,y:y},{x:13,y:y}); return o; })() },
            { id: 7, name: 'Figure Eight', targetApples: 20, star3Time: 72, star2Time: 112, obstacles: (function(){ var o=[]; for(var x=0;x<=19;x++) if(x!==9&&x!==10) o.push({x:x,y:5},{x:x,y:14}); for(var y=0;y<=19;y++) if(y!==9&&y!==10) o.push({x:5,y:y},{x:14,y:y}); return o; })() },
            { id: 8, name: 'Narrow Pass', targetApples: 22, star3Time: 82, star2Time: 125, obstacles: (function(){ var o=[]; for(var y=0;y<=19;y++) { o.push({x:4,y:y},{x:15,y:y}); if(y>=2&&y<=17&&y!==9&&y!==10) o.push({x:7,y:y},{x:12,y:y}); } for(var x=5;x<=6;x++) o.push({x:x,y:0},{x:x,y:1},{x:x,y:18},{x:x,y:19}); for(var x=13;x<=14;x++) o.push({x:x,y:0},{x:x,y:1},{x:x,y:18},{x:x,y:19}); return o; })() },
            { id: 9, name: 'Spiral', targetApples: 25, star3Time: 95, star2Time: 145, obstacles: (function(){ var o=[]; for(var i=2;i<=17;i++) if(i!==9&&i!==10) o.push({x:i,y:2},{x:i,y:17}); for(var i=2;i<=17;i++) o.push({x:2,y:i},{x:17,y:i}); for(var i=5;i<=14;i++) if(i!==9&&i!==10) o.push({x:i,y:5},{x:i,y:14}); for(var i=5;i<=14;i++) if(i!==6&&i!==13) o.push({x:5,y:i},{x:14,y:i}); for(var i=8;i<=11;i++) o.push({x:i,y:8},{x:i,y:11}); for(var i=8;i<=11;i++) if(i!==9&&i!==10) o.push({x:8,y:i},{x:11,y:i}); return o.filter(function(p,i,a){ return a.findIndex(function(q){ return q.x===p.x&&q.y===p.y; })===i; }); })() },
            { id: 10, name: 'Final Boss', targetApples: 30, star3Time: 110, star2Time: 170, obstacles: (function(){ var o=[]; for(var x=0;x<=19;x++) if(x!==4&&x!==9&&x!==10&&x!==15) o.push({x:x,y:3},{x:x,y:16}); for(var y=0;y<=19;y++) if(y!==4&&y!==9&&y!==10&&y!==15) o.push({x:3,y:y},{x:16,y:y}); for(var x=6;x<=13;x++) if(x!==9&&x!==10) o.push({x:x,y:7},{x:x,y:12}); for(var y=7;y<=12;y++) if(y!==9&&y!==10) o.push({x:6,y:y},{x:13,y:y}); return o.filter(function(p,i,a){ return a.findIndex(function(q){ return q.x===p.x&&q.y===p.y; })===i; }); })() }
        ];

        const audioContext = typeof AudioContext !== 'undefined' ? new AudioContext() : null;

        function playSound(frequency, duration, volume) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Fetch SNS (.skr) name - domains are linked to wallet addresses
        // Fetch .skr domain name using Vercel API route (server-side)
        async function getDisplayName(walletAddress) {
            if (!walletAddress || typeof walletAddress !== 'string') {
                return {
                    displayName: 'Invalid wallet',
                    hasDomain: false,
                    isSeeker: false
                };
            }
            
            console.log('[SNS Lookup] Starting lookup for:', walletAddress);
            
            try {
                // Use Vercel API route for server-side .skr domain lookup
                console.log('[SNS Lookup] ðŸ” Calling Vercel API route...');
                const response = await fetch(`/api/get-skr-domain?wallet=${walletAddress}`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('[SNS Lookup] API response:', data);
                    
                    if (data && data.success && data.domain) {
                        console.log('[SNS Lookup] âœ… Found .skr domain:', data.domain);
                        return {
                            displayName: data.domain,
                            hasDomain: true,
                            isSeeker: true
                        };
                    } else {
                        console.log('[SNS Lookup] No .skr domain found via API');
                    }
                } else {
                    console.log('[SNS Lookup] API error:', response.status, response.statusText);
                }
            } catch (error) {
                console.error('[SNS Lookup] Error calling API:', error);
                console.error('[SNS Lookup] Error details:', error.message, error.stack);
            }
            
            // Fallback to shortened wallet address
            console.log('[SNS Lookup] âš ï¸ No .skr domain found, using fallback');
            return {
                displayName: `${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`,
                hasDomain: false,
                isSeeker: false
            };
        }

        function SnakeGame() {
            const [screen, setScreen] = useState('menu');
            const [snake, setSnake] = useState(INITIAL_SNAKE);
            const [direction, setDirection] = useState(INITIAL_DIRECTION);
            const [food, setFood] = useState({x: 15, y: 15});
            const [foodEaten, setFoodEaten] = useState(0);
            const HIGH_SCORE_KEY = 'snakeHighScores';
            const getHighScoreKey = (mode, difficulty) => `${mode}_${difficulty}`;
            const [highScores, setHighScores] = useState(() => {
                try {
                    const raw = localStorage.getItem(HIGH_SCORE_KEY);
                    if (raw) {
                        const obj = JSON.parse(raw);
                        if (obj && typeof obj === 'object') {
                            const migrated = {};
                            for (const k of Object.keys(obj)) {
                                const v = Number(obj[k]);
                                if (v >= 10) migrated[k] = Math.round(v / 10);
                                else migrated[k] = v;
                            }
                            try { localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(migrated)); } catch (_) {}
                            return migrated;
                        }
                    }
                    const legacy = localStorage.getItem('snakeHighScore');
                    if (legacy) {
                        const n = parseInt(legacy, 10);
                        const val = n >= 10 ? Math.round(n / 10) : n;
                        return { classic_medium: val };
                    }
                    return {};
                } catch (_) { return {}; }
            });
            const getHighScore = (mode, difficulty) => highScores[getHighScoreKey(mode, difficulty)] || 0;
            const setHighScoreFor = (mode, difficulty, score) => {
                const key = getHighScoreKey(mode, difficulty);
                setHighScores(prev => {
                    const next = { ...prev, [key]: Math.max(prev[key] || 0, score) };
                    try { localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(next)); } catch (_) {}
                    return next;
                });
            };
            const [obstacles, setObstacles] = useState([]);
            const [speedBoost, setSpeedBoost] = useState(false);
            const [timer, setTimer] = useState(60);
            
            const [settings, setSettings] = useState(() => {
                const defaults = { sound: true, vibration: true, difficulty: 'medium', gameMode: 'classic', snakeColor: 'green', theme: 'dark' };
                try {
                    const s = localStorage.getItem('snakeSettings');
                    if (s) return { ...defaults, ...JSON.parse(s) };
                } catch (_) {}
                return defaults;
            });
            useEffect(() => {
                try { localStorage.setItem('snakeSettings', JSON.stringify(settings)); } catch (_) {}
            }, [settings]);
            useEffect(() => {
                const theme = settings.theme || 'dark';
                document.documentElement.setAttribute('data-theme', theme);
                const meta = document.querySelector('meta[name="theme-color"]');
                if (meta) meta.setAttribute('content', theme === 'light' ? '#f5f5f5' : '#000000');
            }, [settings.theme]);

            const [wallet, setWallet] = useState(null);
            const [snsName, setSnsName] = useState(null);
            const [leaderboard, setLeaderboard] = useState([]);
            const [leaderboardFilter, setLeaderboardFilter] = useState({ mode: 'classic', difficulty: 'medium' });
            const [submittingScore, setSubmittingScore] = useState(false);
            const [loadingLeaderboard, setLoadingLeaderboard] = useState(false);
            const [connectingWallet, setConnectingWallet] = useState(false);
            const [cellSize, setCellSize] = useState(24);

            const LEVEL_STARS_KEY = 'snakeLevelStars';
            const [levelStars, setLevelStars] = useState(() => {
                try {
                    const raw = localStorage.getItem(LEVEL_STARS_KEY);
                    return raw ? JSON.parse(raw) : {};
                } catch (_) { return {}; }
            });
            const [appleCoins, setAppleCoins] = useState(() => {
                try {
                    const raw = localStorage.getItem(APPLE_COINS_KEY);
                    const parsed = raw !== null && raw !== '' ? parseInt(raw, 10) : NaN;
                    const saved = !isNaN(parsed) && parsed >= 0 ? parsed : 0;
                    const isLocal = typeof window !== 'undefined' && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
                    return isLocal ? Math.max(500, saved) : saved;
                } catch (_) { return 0; }
            });
            const [unlockedSkins, setUnlockedSkins] = useState(() => {
                try {
                    const raw = localStorage.getItem(UNLOCKED_SKINS_KEY);
                    return raw ? JSON.parse(raw) : [];
                } catch (_) { return []; }
            });
            useEffect(() => { try { localStorage.setItem(APPLE_COINS_KEY, String(appleCoins)); } catch (_) {} }, [appleCoins]);
            useEffect(() => { try { localStorage.setItem(UNLOCKED_SKINS_KEY, JSON.stringify(unlockedSkins)); } catch (_) {} }, [unlockedSkins]);
            const [levelId, setLevelId] = useState(null);
            const [levelCompleteTime, setLevelCompleteTime] = useState(0);
            const levelStartTimeRef = useRef(0);
            const [ioSnakes, setIoSnakes] = useState([]);
            const [ioFood, setIoFood] = useState([]);
            const [ioLeaderboard, setIoLeaderboard] = useState([]);
            const ioSnakesRef = useRef([]);
            const ioFoodRef = useRef([]);
            const joystickRef = useRef({ x: 0, y: 0 });
            const lastJoystickDirRef = useRef({ x: 1, y: 0 });
            const ioLastFrameRef = useRef(performance.now());
            const ioRafRef = useRef(null);
            const ioGameStartRef = useRef(0);
            const [joystickKnob, setJoystickKnob] = useState({ x: 0, y: 0 });
            const joystickBaseRef = useRef(null);
            const joystickActiveRef = useRef(false);

            const canvasRef = useRef(null);
            const gameLoopRef = useRef(null);
            const directionRef = useRef(INITIAL_DIRECTION);
            const snakeRef = useRef(INITIAL_SNAKE);
            const lastHeadRef = useRef({ x: 10, y: 10 });
            const lastTickRef = useRef(Date.now());
            const gameSessionRef = useRef({ gameMode: 'classic', difficulty: 'medium' });

            const GAME_SPEEDS = { easy: 150, medium: 120, hard: 85 };
            const SURVIVAL_TIME_PER_APPLE = 3;

            // Calculate cell size based on viewport (IO mode uses VIEWPORT_CELLS for a follow-camera view)
            useEffect(() => {
                const calculateCellSize = () => {
                    const availableHeight = window.innerHeight - 80 - 80;
                    const availableWidth = window.innerWidth - 40;
                    const maxDimension = Math.min(availableHeight, availableWidth);
                    const cells = (screen === 'playing' && settings.gameMode === 'io') ? VIEWPORT_CELLS : GRID_SIZE;
                    const calculatedSize = Math.floor(maxDimension / cells);
                    const minSize = 10;
                    const maxSize = 40;
                    const clampedSize = Math.max(minSize, Math.min(maxSize, calculatedSize));
                    setCellSize(clampedSize);
                };
                calculateCellSize();
                window.addEventListener('resize', calculateCellSize);
                return () => window.removeEventListener('resize', calculateCellSize);
            }, [screen, settings.gameMode]);

            // Display: 1 point per apple. Old DB rows may be stored Ã—10, so convert for display only.
            // Only divide if score is clearly old format (>= 100), otherwise return as-is
            const scoreToApples = (s) => {
                const n = Number(s);
                // Old format: scores were stored as 10x (e.g., 160 for 16 apples)
                // New format: scores are stored as-is (e.g., 16 for 16 apples)
                // Only convert if score is >= 100 (clearly old format)
                return n >= 100 ? Math.round(n / 10) : n;
            };

            // Load leaderboard from Supabase
            const loadLeaderboard = async () => {
                try {
                    setLoadingLeaderboard(true);
                    
                    // Get best score per wallet for this mode/difficulty
                    const { data, error } = await supabase
                        .rpc('get_best_scores', {
                            p_game_mode: leaderboardFilter.mode,
                            p_difficulty: leaderboardFilter.difficulty
                        });

                    if (error) {
                        // Fallback if RPC doesn't exist - get all and dedupe client-side
                        const { data: allData, error: fallbackError } = await supabase
                            .from('leaderboards')
                            .select('*')
                            .eq('game_mode', leaderboardFilter.mode)
                            .eq('difficulty', leaderboardFilter.difficulty)
                            .order('score', { ascending: false });

                        if (fallbackError) throw fallbackError;

                        // Keep only best score per wallet (deduplicate by wallet_address only)
                        const bestScores = {};
                        allData.forEach(entry => {
                            const wallet = entry.wallet_address.toLowerCase(); // Normalize to lowercase
                            if (!bestScores[wallet] || entry.score > bestScores[wallet].score) {
                                bestScores[wallet] = entry;
                            }
                        });

                        // Look up domains for all entries
                        const entriesWithDomains = await Promise.all(
                            Object.values(bestScores)
                                .sort((a, b) => scoreToApples(b.score) - scoreToApples(a.score))
                                .slice(0, 100)
                                .map(async (entry, idx) => {
                                    // Look up domain name for this wallet
                                    const displayInfo = await getDisplayName(entry.wallet_address);
                                    const displayName = displayInfo.hasDomain 
                                        ? displayInfo.displayName 
                                        : (entry.skr_name || `${entry.wallet_address.slice(0, 4)}...${entry.wallet_address.slice(-4)}`);
                                    
                                    return {
                                        rank: idx + 1,
                                        name: displayName,
                                        score: scoreToApples(entry.score),
                                        wallet: entry.wallet_address
                                    };
                                })
                        );

                        setLeaderboard(entriesWithDomains);
                    } else {
                        // Deduplicate by wallet_address (in case get_best_scores returns duplicates)
                        const uniqueEntries = {};
                        data.forEach(entry => {
                            const wallet = entry.wallet_address.toLowerCase(); // Normalize to lowercase
                            if (!uniqueEntries[wallet] || entry.best_score > uniqueEntries[wallet].best_score) {
                                uniqueEntries[wallet] = entry;
                            }
                        });

                        // Look up domains for all entries
                        const entriesWithDomains = await Promise.all(
                            Object.values(uniqueEntries)
                                .sort((a, b) => scoreToApples(b.best_score) - scoreToApples(a.best_score))
                                .slice(0, 100)
                                .map(async (entry, idx) => {
                                    // Look up domain name for this wallet
                                    const displayInfo = await getDisplayName(entry.wallet_address);
                                    const displayName = displayInfo.hasDomain 
                                        ? displayInfo.displayName 
                                        : (entry.skr_name || `${entry.wallet_address.slice(0, 4)}...${entry.wallet_address.slice(-4)}`);
                                    
                                    return {
                                        rank: idx + 1,
                                        name: displayName,
                                        score: scoreToApples(entry.best_score),
                                        wallet: entry.wallet_address
                                    };
                                })
                        );

                        setLeaderboard(entriesWithDomains);
                    }
                } catch (err) {
                    console.error('Failed to load leaderboard:', err);
                } finally {
                    setLoadingLeaderboard(false);
                }
            };

            useEffect(() => {
                loadLeaderboard();
            }, [leaderboardFilter]);

            const connectWallet = async () => {
                // Prevent multiple simultaneous connection attempts
                if (connectingWallet || wallet) {
                    console.log('[Snake] Connection already in progress or wallet already connected');
                    return;
                }

                try {
                    setConnectingWallet(true);
                    let pubkey = null;
                    let adapter = window.__snakeWalletAdapter;
                    const isAndroid = /android/i.test(navigator.userAgent);
                    const isInApp = window.__SNAKE_IN_APP || window.ReactNativeWebView;
                    
                    console.log('[Snake] connectWallet called', {
                        isAndroid,
                        isInApp,
                        adapter: adapter ? { ready: adapter.ready, hasConnect: !!adapter?.connect } : 'missing',
                        mwaBundleLoaded: typeof window.__snakeWalletAdapter !== 'undefined',
                        reactNativeWebView: !!window.ReactNativeWebView
                    });

                    // On Android/WebView, wait longer for MWA adapter to initialize
                    if (isAndroid || isInApp) {
                        console.log('[Snake] Waiting for MWA adapter to initialize...');
                        for (let i = 0; i < 30; i++) { // Wait up to 6 seconds
                            adapter = window.__snakeWalletAdapter;
                            if (adapter && adapter.connect && typeof adapter.connect === 'function') {
                                console.log('[Snake] âœ… MWA adapter ready after', i * 200, 'ms');
                                break;
                            }
                            await new Promise(r => setTimeout(r, 200));
                        }
                        console.log('[Snake] After wait, adapter:', adapter ? { 
                            ready: adapter.ready, 
                            hasConnect: !!adapter?.connect,
                            connectType: typeof adapter?.connect
                        } : 'missing');
                    }

                    // 1) Prefer Mobile Wallet Adapter (Seeker / Seed Vault internal wallet)
                    if (adapter && adapter.connect && typeof adapter.connect === 'function') {
                        console.log('[Snake] Attempting MWA connect...');
                        try {
                            const result = await adapter.connect();
                            // Handle both string and object responses
                            pubkey = typeof result === 'string' ? result : (result?.publicKey?.toString() || result?.address || result);
                            if (pubkey) {
                                console.log('[Snake] âœ… MWA connected, pubkey:', pubkey);
                            } else {
                                console.warn('[Snake] MWA connect returned unexpected format:', result);
                            }
                        } catch (mwaErr) {
                            console.warn('[Snake] MWA connect failed:', mwaErr.message, mwaErr);
                            // Don't throw - try Phantom as fallback
                        }
                    } else {
                        console.log('[Snake] MWA adapter not available', {
                            adapter: !!adapter,
                            ready: adapter?.ready,
                            hasConnect: !!adapter?.connect,
                            connectType: typeof adapter?.connect
                        });
                    }

                    // 2) Fallback: Phantom (browser extension or in-app browser)
                    if (!pubkey && window.solana?.isPhantom) {
                        try {
                            const response = await window.solana.connect();
                            pubkey = response.publicKey.toString();
                            console.log('[Snake] âœ… Phantom connected, pubkey:', pubkey);
                        } catch (phantomErr) {
                            console.warn('[Snake] Phantom connect failed:', phantomErr.message);
                        }
                    }

                    if (!pubkey) {
                        // Better error message with actionable guidance
                        const errorMsg = isAndroid || isInApp
                            ? 'Unable to connect wallet. Make sure you\'re using the Seeker device wallet or install Phantom from phantom.app'
                            : 'Please install Phantom wallet from phantom.app';
                        
                        console.error('[Snake] âŒ No wallet available:', {
                            mwaAdapter: !!adapter,
                            mwaReady: adapter?.ready,
                            hasConnect: typeof adapter?.connect,
                            phantomAvailable: !!window.solana?.isPhantom,
                            isAndroid,
                            isInApp,
                            reactNativeWebView: !!window.ReactNativeWebView
                        });
                        
                        // Show error but don't block - user can try again
                        alert(errorMsg);
                        if (!isAndroid && !isInApp) {
                            window.open('https://phantom.app/', '_blank');
                        }
                        setConnectingWallet(false);
                        return;
                    }

                    setWallet(pubkey);
                    const displayInfo = await getDisplayName(pubkey);
                    setSnsName(displayInfo.displayName);
                    console.log('âœ… Wallet connected:', displayInfo.displayName);
                    setConnectingWallet(false);
                } catch (err) {
                    console.error('[Snake] Connection error:', err);
                    alert('Connection failed: ' + (err.message || String(err)) + '. Please try again.');
                    setConnectingWallet(false);
                }
            };

            const disconnectWallet = async () => {
                const adapter = window.__snakeWalletAdapter;
                if (adapter && adapter.disconnect) {
                    try { await adapter.disconnect(); } catch (_) {}
                }
                if (window.solana) {
                    try { window.solana.disconnect(); } catch (_) {}
                }
                setWallet(null);
                setSnsName(null);
                setConnectingWallet(false);
            };

            const generateFood = useCallback(() => {
                let newFood;
                let attempts = 0;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * GRID_SIZE),
                        y: Math.floor(Math.random() * GRID_SIZE)
                    };
                    attempts++;
                } while (
                    attempts < 100 &&
                    (obstacles.some(obs => obs.x === newFood.x && obs.y === newFood.y) ||
                     snake.some(seg => seg.x === newFood.x && seg.y === newFood.y))
                );
                return newFood;
            }, [obstacles, snake]);

            const getInitialIoState = useCallback(() => {
                const half = GRID_SIZE_IO / 2;
                const offset = 10;
                const positions = [
                    { x: half, y: half },
                    { x: half - offset, y: half },
                    { x: half + offset, y: half },
                    { x: half, y: half - offset },
                    { x: half, y: half + offset },
                    { x: half - 7, y: half - 7 }
                ];
                const snakes = positions.slice(0, 1 + Math.min(5, IO_AI_NAMES.length)).map((pos, i) => ({
                    id: i === 0 ? 'player' : 'ai_' + i,
                    name: i === 0 ? 'You' : IO_AI_NAMES[i - 1],
                    body: [{ x: pos.x, y: pos.y }],
                    bodyLength: 1,
                    direction: i === 0 ? { x: 1, y: 0 } : IO_DIRS[Math.floor(Math.random() * 4)],
                    isAI: i !== 0,
                    colorIndex: i % IO_SNAKE_COLORS.length,
                    dead: false
                }));
                const cellKey = (x, y) => Math.floor(x) + ',' + Math.floor(y);
                const allCells = new Set(snakes.flatMap(s => s.body.map(b => cellKey(b.x, b.y))));
                const foodList = [];
                while (foodList.length < IO_NUM_APPLES) {
                    const x = Math.floor(Math.random() * GRID_SIZE_IO) + 0.5;
                    const y = Math.floor(Math.random() * GRID_SIZE_IO) + 0.5;
                    if (!allCells.has(cellKey(x, y))) {
                        foodList.push({ x, y });
                        allCells.add(cellKey(x, y));
                    }
                }
                return { snakes, foodList };
            }, []);

            const generateObstacles = useCallback(() => {
                const numObstacles = settings.gameMode === 'walls' ? 10 : 0;
                const newObstacles = [];
                for (let i = 0; i < numObstacles; i++) {
                    let obstacle;
                    let attempts = 0;
                    do {
                        obstacle = {
                            x: Math.floor(Math.random() * GRID_SIZE),
                            y: Math.floor(Math.random() * GRID_SIZE)
                        };
                        attempts++;
                    } while (
                        attempts < 100 &&
                        (newObstacles.some(obs => obs.x === obstacle.x && obs.y === obstacle.y) ||
                         INITIAL_SNAKE.some(seg => seg.x === obstacle.x && seg.y === obstacle.y) ||
                         (obstacle.x === 15 && obstacle.y === 15))
                    );
                    newObstacles.push(obstacle);
                }
                return newObstacles;
            }, [settings.gameMode]);

            const vibrate = (pattern) => {
                if (settings.vibration && navigator.vibrate) {
                    navigator.vibrate(pattern);
                }
            };

            const handleDirectionChange = (newDirection) => {
                if (screen !== 'playing' || settings.gameMode === 'io') return;
                const currentDir = directionRef.current;
                if (newDirection.x === -currentDir.x && newDirection.y === -currentDir.y) return;
                directionRef.current = newDirection;
                setDirection(newDirection);
                vibrate(10);
            };

            const startGame = (overrides) => {
                const mode = overrides?.gameMode ?? settings.gameMode;
                const difficulty = overrides?.difficulty ?? settings.difficulty;
                if (overrides?.gameMode != null || overrides?.difficulty != null) {
                    setSettings(prev => ({ ...prev, gameMode: mode, difficulty }));
                }
                setLevelId(null);
                gameSessionRef.current = { gameMode: mode, difficulty };
                setIoLeaderboard([]);
                if (mode === 'io') {
                    ioGameStartRef.current = performance.now();
                    const { snakes, foodList } = getInitialIoState();
                    setIoSnakes(snakes);
                    setIoFood(foodList);
                    ioSnakesRef.current = snakes;
                    ioFoodRef.current = foodList;
                    joystickRef.current = { x: 0, y: 0 };
                    lastJoystickDirRef.current = { x: 1, y: 0 };
                    setJoystickKnob({ x: 0, y: 0 });
                    setSnake(snakes[0].body);
                    snakeRef.current = snakes[0].body;
                    lastHeadRef.current = { x: snakes[0].body[0].x, y: snakes[0].body[0].y };
                    setFoodEaten(0);
                    setObstacles([]);
                    setScreen('playing');
                    return;
                }
                setSnake(INITIAL_SNAKE);
                snakeRef.current = INITIAL_SNAKE;
                lastHeadRef.current = { x: INITIAL_SNAKE[0].x, y: INITIAL_SNAKE[0].y };
                lastTickRef.current = Date.now();
                setDirection(INITIAL_DIRECTION);
                directionRef.current = INITIAL_DIRECTION;
                setFood(generateFood());
                setFoodEaten(0);
                setSpeedBoost(false);
                setTimer(60);
                if (mode === 'walls') {
                    setObstacles(generateObstacles());
                } else {
                    setObstacles([]);
                }
                setScreen('playing');
            };

            const startLevel = (id) => {
                const level = LEVELS[id - 1];
                if (!level) return;
                gameSessionRef.current = { gameMode: 'classic', difficulty: settings.difficulty, levelId: id };
                setLevelId(id);
                levelStartTimeRef.current = Date.now();
                setSnake(INITIAL_SNAKE);
                snakeRef.current = INITIAL_SNAKE;
                lastHeadRef.current = { x: INITIAL_SNAKE[0].x, y: INITIAL_SNAKE[0].y };
                lastTickRef.current = Date.now();
                setDirection(INITIAL_DIRECTION);
                directionRef.current = INITIAL_DIRECTION;
                setObstacles(level.obstacles || []);
                setFoodEaten(0);
                setSpeedBoost(false);
                setTimer(60);
                setScreen('playing');
                setFood(() => {
                    let newFood;
                    let attempts = 0;
                    const obs = level.obstacles || [];
                    const snakePos = INITIAL_SNAKE;
                    do {
                        newFood = { x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE) };
                        attempts++;
                    } while (attempts < 100 && (obs.some(o => o.x === newFood.x && o.y === newFood.y) || snakePos.some(s => s.x === newFood.x && s.y === newFood.y)));
                    return newFood;
                });
            };

            const submitScore = async (finalFoodCount) => {
                const apples = finalFoodCount;
                const session = gameSessionRef.current;

                if (wallet && apples > getHighScore(session.gameMode, session.difficulty)) {
                    setHighScoreFor(session.gameMode, session.difficulty, apples);
                }

                if (apples === 0 || !wallet) {
                    console.log('No score to submit or no wallet connected');
                    return;
                }

                setSubmittingScore(true);

                try {
                    const { error } = await supabase
                        .from('leaderboards')
                        .insert({
                            wallet_address: wallet,
                            skr_name: snsName,
                            score: apples,
                            game_mode: session.gameMode,
                            difficulty: session.difficulty
                        });

                    if (error) throw error;

                    console.log('Score submitted successfully!');
                    setLeaderboardFilter({ mode: session.gameMode, difficulty: session.difficulty });
                } catch (err) {
                    console.error('Failed to submit score:', err);
                    alert('Could not save score to leaderboard. Try again.');
                } finally {
                    setSubmittingScore(false);
                }
            };

            const checkCollision = useCallback((head) => {
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    if (levelId || settings.gameMode !== 'portal') return true;
                }
                if (obstacles.some(obs => obs.x === head.x && obs.y === head.y)) return true;
                return false;
            }, [obstacles, settings.gameMode, levelId]);

            const gameLoop = useCallback(() => {
                const body = snakeRef.current;
                if (!body || body.length === 0) return;
                
                let head = {
                    x: body[0].x + directionRef.current.x,
                    y: body[0].y + directionRef.current.y
                };

                if (settings.gameMode === 'portal' && !levelId) {
                    if (head.x < 0) head.x = GRID_SIZE - 1;
                    if (head.x >= GRID_SIZE) head.x = 0;
                    if (head.y < 0) head.y = GRID_SIZE - 1;
                    if (head.y >= GRID_SIZE) head.y = 0;
                }

                // Self-collision: check new head against body segments
                // Skip the tail (last segment) since it will be removed when snake moves
                // Unless the head is eating food, in which case we check all segments
                const willEatFood = head.x === food.x && head.y === food.y;
                const segmentsToCheck = willEatFood ? body.length : body.length - 1;
                
                for (let i = 0; i < segmentsToCheck; i++) {
                    if (head.x === body[i].x && head.y === body[i].y) {
                        if (gameLoopRef.current) {
                            clearInterval(gameLoopRef.current);
                            gameLoopRef.current = null;
                        }
                        setScreen('gameOver');
                        submitScore(foodEaten);
                        if (settings.sound) playSound(100, 0.3, 0.3);
                        vibrate([200, 100, 200]);
                        return;
                    }
                }
                if (checkCollision(head)) {
                    if (gameLoopRef.current) {
                        clearInterval(gameLoopRef.current);
                        gameLoopRef.current = null;
                    }
                    setScreen('gameOver');
                    submitScore(foodEaten);
                    if (settings.sound) playSound(100, 0.3, 0.3);
                    vibrate([200, 100, 200]);
                    return;
                }

                let newSnake = [head, ...body];

                if (head.x === food.x && head.y === food.y) {
                    const newCount = foodEaten + 1;
                    setFoodEaten(f => f + 1);
                    setAppleCoins(c => c + 1);
                    setFood(generateFood());
                    if (settings.sound) playSound(800, 0.1, 0.2);
                    vibrate(50);
                    if (settings.gameMode === 'survival') {
                        setTimer(t => t + SURVIVAL_TIME_PER_APPLE);
                    }
                    if (settings.gameMode === 'speed') {
                        setSpeedBoost(true);
                        setTimeout(() => setSpeedBoost(false), 3000);
                    }
                    if (levelId && newCount >= LEVELS[levelId - 1].targetApples) {
                        if (gameLoopRef.current) { clearInterval(gameLoopRef.current); gameLoopRef.current = null; }
                        const elapsed = (Date.now() - levelStartTimeRef.current) / 1000;
                        const lev = LEVELS[levelId - 1];
                        const stars = elapsed <= lev.star3Time ? 3 : elapsed <= lev.star2Time ? 2 : 1;
                        setLevelCompleteTime(elapsed);
                        setLevelStars(prev => {
                            const next = { ...prev, [levelId]: Math.max(prev[levelId] || 0, stars) };
                            try { localStorage.setItem(LEVEL_STARS_KEY, JSON.stringify(next)); } catch (_) {}
                            return next;
                        });
                        setScreen('levelComplete');
                    }
                } else {
                    newSnake.pop();
                }

                lastHeadRef.current = { x: body[0].x, y: body[0].y };
                lastTickRef.current = Date.now();
                snakeRef.current = newSnake;
                setSnake(newSnake);
            }, [food, checkCollision, foodEaten, generateFood, settings.sound, settings.vibration, settings.gameMode, levelId]);

            useEffect(() => {
                if (screen === 'playing' && settings.gameMode !== 'io') {
                    let speed = GAME_SPEEDS[settings.difficulty] ?? GAME_SPEEDS.hard;
                    if (settings.gameMode === 'speed' && speedBoost) {
                        speed = Math.max(speed - 50, 50);
                    }
                    gameLoopRef.current = setInterval(gameLoop, speed);
                    return () => clearInterval(gameLoopRef.current);
                }
            }, [screen, gameLoop, settings.difficulty, settings.gameMode, speedBoost]);

            function trimBodyToLength(path, bodyLength) {
                if (!path.length || bodyLength <= 0) return path.length ? [path[0]] : [];
                if (path.length === 1) return path;
                let len = 0;
                const result = [path[0]];
                for (let i = 1; i < path.length; i++) {
                    const d = Math.hypot(path[i].x - path[i-1].x, path[i].y - path[i-1].y);
                    if (len + d <= bodyLength) {
                        result.push(path[i]);
                        len += d;
                    } else {
                        const t = d > 0 ? (bodyLength - len) / d : 0;
                        result.push({
                            x: path[i-1].x + t * (path[i].x - path[i-1].x),
                            y: path[i-1].y + t * (path[i].y - path[i-1].y)
                        });
                        return result;
                    }
                }
                return result;
            }

            const ioFreeMoveLoop = useCallback((now) => {
                const snakes = ioSnakesRef.current;
                const foodList = ioFoodRef.current;
                if (!snakes || !Array.isArray(snakes) || snakes.length === 0) return;
                const playerSnake = snakes.find(s => s.id === 'player');
                if (!playerSnake || playerSnake.dead) return;
                if (!playerSnake.body || playerSnake.body.length === 0) return;

                const dt = Math.max(0, Math.min(0.05, (now - ioLastFrameRef.current) / 1000));
                ioLastFrameRef.current = now;
                const gracePeriod = 1200;
                const playerGrace = (now - ioGameStartRef.current) < gracePeriod;

                const dist = (a, b) => Math.hypot(b.x - a.x, b.y - a.y);
                const allBodyPoints = [];
                snakes.forEach(s => {
                    if (!s.dead) s.body.forEach((p, i) => allBodyPoints.push({ ...p, snakeId: s.id, segIdx: i, isTail: i === s.body.length - 1 }));
                });

                const newSnakes = snakes.map(s => {
                    if (s.dead) return s;
                    const head = s.body[0];
                    let dx, dy;
                    if (s.id === 'player') {
                        const j = joystickRef.current;
                        const len = Math.hypot(j.x, j.y);
                        if (len >= 0.15) {
                            dx = j.x / len;
                            dy = j.y / len;
                            lastJoystickDirRef.current = { x: dx, y: dy };
                        } else {
                            dx = lastJoystickDirRef.current.x;
                            dy = lastJoystickDirRef.current.y;
                        }
                    } else {
                        const head = s.body[0];
                        let bestDir = s.direction;
                        let bestScore = -1e9;
                        for (const d of IO_DIRS) {
                            const nx = head.x + d.x * 0.5, ny = head.y + d.y * 0.5;
                            if (nx < 0 || nx >= GRID_SIZE_IO || ny < 0 || ny >= GRID_SIZE_IO) continue;
                            let minDistToBody = 1e9;
                            allBodyPoints.forEach(pt => {
                                if (pt.snakeId === s.id && (pt.segIdx === 0 || pt.isTail)) return;
                                const dd = Math.hypot(nx - pt.x, ny - pt.y);
                                if (dd < minDistToBody) minDistToBody = dd;
                            });
                            if (minDistToBody < IO_SEGMENT_RADIUS * 2) continue;
                            let foodDist = 1e9;
                            foodList.forEach(f => { const fd = Math.hypot(nx - f.x, ny - f.y); if (fd < foodDist) foodDist = fd; });
                            const score = -foodDist * 2 + minDistToBody;
                            if (score > bestScore) { bestScore = score; bestDir = d; }
                        }
                        dx = bestDir.x;
                        dy = bestDir.y;
                    }
                    const newHead = {
                        x: head.x + dx * IO_FREE_SPEED * dt,
                        y: head.y + dy * IO_FREE_SPEED * dt
                    };
                    let newBody = trimBodyToLength([newHead, ...s.body], s.bodyLength);
                    return { ...s, body: newBody, direction: { x: dx, y: dy } };
                });

                const deaths = new Set();
                newSnakes.forEach(s => {
                    if (s.dead) return;
                    if (s.id === 'player' && playerGrace) return;
                    const h = s.body[0];
                    if (h.x < 0 || h.x >= GRID_SIZE_IO || h.y < 0 || h.y >= GRID_SIZE_IO) { deaths.add(s.id); return; }
                    let pathLen = 0;
                    for (let i = 1; i < s.body.length; i++) {
                        pathLen += dist(s.body[i - 1], s.body[i]);
                        if (pathLen >= IO_SELF_COLLIDE_MIN_DIST && dist(h, s.body[i]) < IO_COLLIDE_RADIUS + IO_SEGMENT_RADIUS) {
                            deaths.add(s.id);
                            break;
                        }
                    }
                    newSnakes.forEach(other => {
                        if (other.dead || other.id === s.id) return;
                        for (let i = 0; i < other.body.length; i++) {
                            if (dist(h, other.body[i]) < IO_COLLIDE_RADIUS + IO_SEGMENT_RADIUS) {
                                deaths.add(s.id);
                                return;
                            }
                        }
                    });
                });

                const eatenIndices = new Set();
                let newFood = [...foodList];
                const updatedSnakes = newSnakes.map(s => {
                    if (s.dead || deaths.has(s.id)) return { ...s, dead: s.dead || deaths.has(s.id) };
                    const h = s.body[0];
                    const idx = foodList.findIndex(f => dist(h, f) < IO_EAT_RADIUS);
                    if (idx >= 0 && !eatenIndices.has(idx)) {
                        eatenIndices.add(idx);
                        if (s.id === 'player') setAppleCoins(c => c + 1);
                        newFood = newFood.filter((_, i) => i !== idx);
                        return { ...s, bodyLength: s.bodyLength + 1 };
                    }
                    return s;
                }).map(s => deaths.has(s.id) ? { ...s, dead: true } : s);

                const allPts = new Set(updatedSnakes.flatMap(s => s.body.map(p => Math.floor(p.x) + ',' + Math.floor(p.y))));
                eatenIndices.forEach(() => {
                    for (let att = 0; att < 80; att++) {
                        const x = Math.random() * (GRID_SIZE_IO - 1) + 0.5;
                        const y = Math.random() * (GRID_SIZE_IO - 1) + 0.5;
                        const key = Math.floor(x) + ',' + Math.floor(y);
                        if (!allPts.has(key)) {
                            newFood.push({ x, y });
                            allPts.add(key);
                            break;
                        }
                    }
                });

                ioSnakesRef.current = updatedSnakes;
                ioFoodRef.current = newFood;
                setIoSnakes(updatedSnakes);
                setIoFood(newFood);
                const player = updatedSnakes.find(s => s.id === 'player');
                if (player) {
                    snakeRef.current = player.body;
                    lastHeadRef.current = player.body[0];
                    setSnake(player.body);
                }
                if (player && player.dead) {
                    if (ioRafRef.current) cancelAnimationFrame(ioRafRef.current);
                    ioRafRef.current = null;
                    const leaderboard = [...updatedSnakes]
                        .sort((a, b) => b.bodyLength - a.bodyLength)
                        .map(s => ({ name: s.name, length: Math.round(s.bodyLength), isPlayer: s.id === 'player', dead: s.dead }));
                    setIoLeaderboard(leaderboard);
                    setFoodEaten(Math.round(player.bodyLength));
                    submitScore(Math.round(player.bodyLength));
                    if (settings.sound) playSound(100, 0.3, 0.3);
                    vibrate([200, 100, 200]);
                    setScreen('gameOver');
                }
            }, [settings.sound, settings.vibration]);

            function ioRafLoop(now) {
                ioFreeMoveLoop(now);
                if (ioRafRef.current !== null) ioRafRef.current = requestAnimationFrame(ioRafLoop);
            }

            useEffect(() => {
                if (screen === 'playing' && settings.gameMode === 'io') {
                    if (ioSnakes && Array.isArray(ioSnakes) && ioSnakes.length > 0) {
                        ioSnakesRef.current = ioSnakes;
                    }
                    if (ioFood && Array.isArray(ioFood)) {
                        ioFoodRef.current = ioFood;
                    }
                }
            }, [screen, settings.gameMode, ioSnakes, ioFood]);

            useEffect(() => {
                if (screen === 'playing' && settings.gameMode === 'io') {
                    ioLastFrameRef.current = performance.now();
                    ioRafRef.current = requestAnimationFrame(ioRafLoop);
                    return () => {
                        if (ioRafRef.current) cancelAnimationFrame(ioRafRef.current);
                        ioRafRef.current = null;
                    };
                }
            }, [screen, settings.gameMode]);

            useEffect(() => {
                if (screen === 'playing' && settings.gameMode === 'survival') {
                    const timerInterval = setInterval(() => {
                        setTimer(t => {
                            if (t <= 1) {
                                setScreen('gameOver');
                                submitScore(foodEaten);
                                return 0;
                            }
                            return t - 1;
                        });
                    }, 1000);
                    return () => clearInterval(timerInterval);
                }
            }, [screen, settings.gameMode, foodEaten]);

            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (screen === 'playing' && settings.gameMode !== 'io') {
                        const currentDir = directionRef.current;
                        if (e.key === 'ArrowUp' && currentDir.y === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 0, y: -1});
                        } else if (e.key === 'ArrowDown' && currentDir.y === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 0, y: 1});
                        } else if (e.key === 'ArrowLeft' && currentDir.x === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: -1, y: 0});
                        } else if (e.key === 'ArrowRight' && currentDir.x === 0) {
                            e.preventDefault();
                            handleDirectionChange({x: 1, y: 0});
                        } else if (e.key === 'Escape' || e.key === ' ') {
                            e.preventDefault();
                            setScreen('paused');
                        }
                    } else if (screen === 'paused' && (e.key === 'Escape' || e.key === ' ')) {
                        e.preventDefault();
                        setScreen('playing');
                    }
                };
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [screen]);

            useEffect(() => {
                if (screen !== 'playing') return;
                let touchStartX = 0, touchStartY = 0;
                let swipeHandled = false;
                const SWIPE_THRESHOLD = 20; // px â€“ react as soon as swipe is clear
                const applySwipeDirection = (deltaX, deltaY) => {
                    if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD) return false;
                    const currentDir = directionRef.current;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0 && currentDir.x === 0) { handleDirectionChange({x: 1, y: 0}); return true; }
                        if (deltaX < 0 && currentDir.x === 0) { handleDirectionChange({x: -1, y: 0}); return true; }
                    } else {
                        if (deltaY > 0 && currentDir.y === 0) { handleDirectionChange({x: 0, y: 1}); return true; }
                        if (deltaY < 0 && currentDir.y === 0) { handleDirectionChange({x: 0, y: -1}); return true; }
                    }
                    return false;
                };
                const handleTouchStart = (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                    touchStartY = e.changedTouches[0].screenY;
                    swipeHandled = false;
                };
                const handleTouchMove = (e) => {
                    if (swipeHandled || !e.touches.length) return;
                    const deltaX = e.touches[0].screenX - touchStartX;
                    const deltaY = e.touches[0].screenY - touchStartY;
                    if (applySwipeDirection(deltaX, deltaY)) swipeHandled = true;
                };
                const handleTouchEnd = (e) => {
                    if (swipeHandled) return;
                    const deltaX = e.changedTouches[0].screenX - touchStartX;
                    const deltaY = e.changedTouches[0].screenY - touchStartY;
                    applySwipeDirection(deltaX, deltaY);
                };
                window.addEventListener('touchstart', handleTouchStart, {passive: true});
                window.addEventListener('touchmove', handleTouchMove, {passive: true});
                window.addEventListener('touchend', handleTouchEnd, {passive: true});
                return () => {
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchmove', handleTouchMove);
                    window.removeEventListener('touchend', handleTouchEnd);
                };
            }, [screen]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                let interval = GAME_SPEEDS[settings.difficulty] ?? GAME_SPEEDS.hard;
                if (settings.gameMode === 'speed' && speedBoost) interval = Math.max(interval - 50, 50);

                function draw() {
                    const canvasBg = (settings.theme === 'light') ? '#e8e8e8' : '#000';
                    const obstacleBg = (settings.theme === 'light') ? '#ccc' : '#1a1a1a';
                    ctx.fillStyle = canvasBg;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const ioSnakesNow = ioSnakesRef.current;
                    const ioFoodNow = ioFoodRef.current;
                    if (settings.gameMode === 'io' && ioSnakesNow && ioSnakesNow.length > 0) {
                        const player = ioSnakesNow.find(s => s.id === 'player');
                        const half = VIEWPORT_CELLS / 2;
                        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
                        let camX = half, camY = half;
                        if (player && !player.dead && player.body && player.body[0]) {
                            camX = clamp(player.body[0].x, half, GRID_SIZE_IO - 1 - half);
                            camY = clamp(player.body[0].y, half, GRID_SIZE_IO - 1 - half);
                        }
                        ctx.save();
                        ctx.translate(-camX * cellSize + canvas.width / 2, -camY * cellSize + canvas.height / 2);
                        (ioFoodNow || []).forEach(function(f) {
                            const cx = f.x * cellSize + cellSize / 2;
                            const cy = f.y * cellSize + cellSize / 2;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.font = (cellSize - 2) + 'px sans-serif';
                            ctx.fillText('ðŸŽ', cx, cy);
                        });
                        const segW = cellSize - 2;
                        ioSnakesNow.forEach(function(s) {
                            if (s.dead || !s.body || !s.body.length) return;
                            const color = IO_SNAKE_COLORS[s.colorIndex % IO_SNAKE_COLORS.length];
                            s.body.forEach(function(seg) {
                                const x = Math.floor(seg.x * cellSize) + 1;
                                const y = Math.floor(seg.y * cellSize) + 1;
                                ctx.fillStyle = color;
                                ctx.fillRect(x, y, segW, segW);
                            });
                        });
                        ctx.restore();
                        return;
                    }

                    const body = snakeRef.current;
                    if (!body || body.length === 0) return;
                    if (!lastHeadRef.current) lastHeadRef.current = { x: body[0].x, y: body[0].y };
                    const now = Date.now();
                    const alpha = Math.min(1, (now - lastTickRef.current) / interval);

                    if (obstacles.length > 0) {
                        ctx.fillStyle = obstacleBg;
                        obstacles.forEach(function(obs) {
                            ctx.fillRect(obs.x * cellSize, obs.y * cellSize, cellSize - 1, cellSize - 1);
                        });
                    }

                    const snakeColor = SNAKE_SKINS[settings.snakeColor] || SNAKE_SKINS.green;
                    const isPortal = settings.gameMode === 'portal' && !levelId;
                    const wrap = (v, size) => ((v % size) + size) % size;
                    const shortestDelta = (from, to, size) => {
                        let d = to - from;
                        if (d > size / 2) d -= size;
                        else if (d < -size / 2) d += size;
                        return d;
                    };
                    for (var i = 0; i < body.length; i++) {
                        var px, py;
                        if (i === 0) {
                            var hx, hy;
                            if (isPortal) {
                                var dx = shortestDelta(lastHeadRef.current.x, body[0].x, GRID_SIZE);
                                var dy = shortestDelta(lastHeadRef.current.y, body[0].y, GRID_SIZE);
                                hx = wrap(lastHeadRef.current.x + dx * alpha, GRID_SIZE);
                                hy = wrap(lastHeadRef.current.y + dy * alpha, GRID_SIZE);
                            } else {
                                hx = lastHeadRef.current.x + (body[0].x - lastHeadRef.current.x) * alpha;
                                hy = lastHeadRef.current.y + (body[0].y - lastHeadRef.current.y) * alpha;
                            }
                            px = hx * cellSize;
                            py = hy * cellSize;
                        } else {
                            px = body[i].x * cellSize;
                            py = body[i].y * cellSize;
                        }
                        var x = Math.floor(px) + 1, y = Math.floor(py) + 1;
                        const segColor = speedBoost ? '#FFD700' : (settings.snakeColor === 'rainbow' ? ROYGBIV[i % 7] : snakeColor);
                        const segW = cellSize - 2;
                        if (settings.snakeColor === 'gold' && !speedBoost) {
                            const g = ctx.createLinearGradient(x, y, x + segW, y + segW);
                            g.addColorStop(0, '#F7E7CE');
                            g.addColorStop(0.35, '#E8C547');
                            g.addColorStop(0.7, '#B8860B');
                            g.addColorStop(1, '#8B6914');
                            ctx.fillStyle = g;
                        } else {
                            ctx.fillStyle = segColor;
                        }
                        ctx.fillRect(x, y, segW, segW);
                        if (settings.snakeColor === 'leopard' && !speedBoost) {
                            ctx.fillStyle = '#4a3728';
                            const spotSize = Math.max(2, Math.floor(segW / 7));
                            const r = (i, a, b) => ((i * 7 + a) * 11 + b) % 100;
                            if (i === 0) {
                                ctx.fillRect(x + (r(i, 1, 2) % (segW - spotSize)), y + (r(i, 3, 1) % (segW - spotSize)), spotSize, spotSize);
                            } else if (i < body.length - 1) {
                                const n = 1 + (i % 3);
                                for (let s = 0; s < n; s++) {
                                    const sx = x + 1 + (r(i, s, 0) % (segW - spotSize - 2));
                                    const sy = y + 1 + (r(i, s, 5) % (segW - spotSize - 2));
                                    ctx.fillRect(sx, sy, spotSize, spotSize);
                                }
                            }
                            ctx.fillStyle = snakeColor;
                        }
                    }

                    const foodCenterX = food.x * cellSize + cellSize / 2;
                    const foodCenterY = food.y * cellSize + cellSize / 2;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = (cellSize - 2) + 'px sans-serif';
                    ctx.fillText('ðŸŽ', foodCenterX, foodCenterY);
                }

                var rafId;
                function loop() {
                    draw();
                    rafId = requestAnimationFrame(loop);
                }
                rafId = requestAnimationFrame(loop);
                return function() { cancelAnimationFrame(rafId); };
            }, [snake, food, obstacles, speedBoost, cellSize, settings.snakeColor, settings.difficulty, settings.gameMode, settings.theme, levelId]);

            if (screen === 'menu') {
                return (
                    <div className="fullscreen menu-fullscreen">
                        <div className="menu-container">
                            <div className="menu-card">
                                <header className="menu-header">
                                    <div className="logo-big">
                                        <span className="logo-accent">â—¢</span> SNAKE
                                    </div>
                                    <div className="menu-tagline">Solana Seeker</div>
                                </header>
                                <div className="menu-primary">
                                    <button className="menu-button" onClick={() => setScreen('playSelect')}>
                                        Play
                                    </button>
                                </div>
                                <div className="menu-divider" aria-hidden />
                                <nav className="menu-nav">
                                    <button className="menu-button secondary" onClick={() => setScreen('levels')}>
                                        Levels
                                    </button>
                                    <button className="menu-button secondary" onClick={() => setScreen('shop')}>
                                        Shop
                                    </button>
                                    <button className="menu-button secondary" onClick={() => setScreen('settings')}>
                                        Settings
                                    </button>
                                    <button className="menu-button secondary" onClick={() => setScreen('leaderboard')}>
                                        Leaderboard
                                    </button>
                                    {!wallet ? (
                                        <button
                                            className="menu-button secondary"
                                            onClick={connectWallet}
                                            disabled={connectingWallet}
                                        >
                                            {connectingWallet ? 'Connectingâ€¦' : 'Connect wallet'}
                                        </button>
                                    ) : (
                                        <button className="menu-button secondary" onClick={disconnectWallet}>
                                            Disconnect
                                        </button>
                                    )}
                                </nav>
                                {wallet && (
                                    <div className="menu-wallet-wrap">
                                        <div className="wallet-display">
                                            {snsName || 'â€¦'}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            const GAME_MODES = [
                { id: 'classic', name: 'Classic', desc: 'No walls, wrap or die' },
                { id: 'walls', name: 'Walls', desc: 'Avoid obstacles' },
                { id: 'portal', name: 'Portal', desc: 'Wrap around edges' },
                { id: 'speed', name: 'Speed', desc: 'Collect orbs for boost' },
                { id: 'survival', name: 'Survival', desc: 'Eat to add time' },
                { id: 'io', name: 'Battle (vs AI)', desc: 'Snake.io style: eat apples, avoid others' }
            ];

            if (screen === 'playSelect') {
                return (
                    <div className="fullscreen">
                        <div className="play-select-container">
                            <div className="play-select-header">
                                <div className="play-select-title">Choose game mode</div>
                                <div className="play-select-difficulty">
                                    <label>Difficulty</label>
                                    <select
                                        className="select-box"
                                        value={settings.difficulty}
                                        onChange={(e) => setSettings({ ...settings, difficulty: e.target.value })}
                                    >
                                        <option value="easy">Easy</option>
                                        <option value="medium">Medium</option>
                                        <option value="hard">Hard</option>
                                    </select>
                                </div>
                            </div>
                            {GAME_MODES.map((m) => (
                                <div
                                    key={m.id}
                                    className="mode-row"
                                    onClick={() => startGame({ gameMode: m.id, difficulty: settings.difficulty })}
                                >
                                    <div>
                                        <div className="mode-name">{m.name}</div>
                                        <div className="mode-desc">{m.desc}</div>
                                    </div>
                                </div>
                            ))}
                            <button className="menu-button secondary" style={{ marginTop: 24 }} onClick={() => setScreen('menu')}>
                                BACK
                            </button>
                        </div>
                    </div>
                );
            }

            if (screen === 'shop') {
                return (
                    <div className="fullscreen shop-fullscreen">
                        <div className="shop-container">
                            <div className="shop-header">
                                <h1 className="shop-title">Item Shop</h1>
                                <div className="shop-balance-pill">
                                    <span className="shop-currency-icon" aria-hidden>ðŸŽ</span>
                                    <span>{appleCoins}</span>
                                </div>
                            </div>
                            <p style={{ fontSize: '0.85em', color: 'var(--text-muted)', marginBottom: 24 }}>
                                Earn apples by eating fruit. Unlock skins to show off in game.
                            </p>
                            <div className="shop-section-label">Featured</div>
                            <div className="shop-grid">
                                {SHOP_SKINS.map((item) => {
                                    const owned = unlockedSkins.includes(item.id);
                                    const canBuy = !owned && appleCoins >= item.price;
                                    const rarity = SHOP_RARITIES[item.rarity] || SHOP_RARITIES.rare;
                                    return (
                                        <div
                                            key={item.id}
                                            className={`shop-card shop-card-rare ${owned ? 'owned' : ''}`}
                                            style={{
                                                '--shop-rarity-border': rarity.border,
                                                '--shop-rarity-glow': rarity.glow
                                            }}
                                        >
                                            <div className="shop-card-preview-wrap">
                                                <div className="shop-skin-preview-wrap" aria-hidden>
                                                    <ShopSnakePreview skinId={item.id} size="large" />
                                                </div>
                                            </div>
                                            <div className="shop-card-body">
                                                <div className="shop-card-rarity" style={{ color: rarity.color }}>
                                                    {rarity.label}
                                                </div>
                                                <div className="shop-card-name">{item.name}</div>
                                                <div className="shop-card-footer">
                                                    {!owned ? (
                                                        <>
                                                            <div className="shop-card-price">
                                                                <span className="shop-currency-icon" aria-hidden>ðŸŽ</span>
                                                                <span>{item.price}</span>
                                                            </div>
                                                            <button
                                                                className="shop-card-buy"
                                                                disabled={!canBuy}
                                                                onClick={() => {
                                                                    if (appleCoins >= item.price) {
                                                                        setAppleCoins(c => c - item.price);
                                                                        setUnlockedSkins(prev => [...prev, item.id]);
                                                                    }
                                                                }}
                                                            >
                                                                Buy
                                                            </button>
                                                        </>
                                                    ) : (
                                                        <div className="shop-owned-badge">Owned</div>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                            <div className="shop-back-wrap">
                                <button className="menu-button secondary" onClick={() => setScreen('menu')}>
                                    Back
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            if (screen === 'levels') {
                return (
                    <div className="fullscreen">
                        <div className="levels-container">
                            <div className="levels-title">LEVELS</div>
                            <div className="levels-subtitle">Collect apples to finish. 3â˜… fast, 2â˜… medium, 1â˜… complete.</div>
                            <div className="levels-grid">
                                {LEVELS.map((lev) => {
                                    const unlocked = lev.id === 1 || (levelStars[lev.id - 1] !== undefined && levelStars[lev.id - 1] > 0);
                                    const stars = levelStars[lev.id] || 0;
                                    return (
                                        <div
                                            key={lev.id}
                                            className={`level-card ${unlocked ? '' : 'locked'}`}
                                            onClick={() => unlocked && startLevel(lev.id)}
                                        >
                                            <div className="level-num">{lev.id}</div>
                                            <div className="level-name">{lev.name}</div>
                                            <div className={`level-stars ${stars === 0 ? 'empty' : ''}`}>
                                                {'â˜…'.repeat(stars)}{'â˜†'.repeat(3 - stars)}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                            <button className="menu-button secondary" onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            if (screen === 'settings') {
                return (
                    <div className="fullscreen">
                        <div className="settings-container">
                            <div className="settings-title">SETTINGS</div>
                            
                            <div className="setting-row">
                                <div className="setting-name">Appearance</div>
                                <select 
                                    className="select-box"
                                    value={settings.theme || 'dark'}
                                    onChange={(e) => setSettings({...settings, theme: e.target.value})}
                                >
                                    <option value="dark">Dark mode</option>
                                    <option value="light">Light mode</option>
                                </select>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Sound</div>
                                <div 
                                    className={`toggle ${settings.sound ? 'active' : ''}`}
                                    onClick={() => setSettings({...settings, sound: !settings.sound})}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Vibration</div>
                                <div 
                                    className={`toggle ${settings.vibration ? 'active' : ''}`}
                                    onClick={() => setSettings({...settings, vibration: !settings.vibration})}
                                >
                                    <div className="toggle-knob"></div>
                                </div>
                            </div>

                            <div className="setting-row">
                                <div className="setting-name">Snake color</div>
                                <div className="skin-swatches">
                                    {[...SNAKE_SKIN_IDS, ...unlockedSkins].filter((id, i, a) => a.indexOf(id) === i).map((id) => (
                                        <button
                                            key={id}
                                            type="button"
                                            className={`skin-swatch ${settings.snakeColor === id ? 'active' : ''}`}
                                            style={id === 'rainbow' ? { background: 'linear-gradient(to right, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #8B00FF)' } : { backgroundColor: SNAKE_SKINS[id] }}
                                            title={id}
                                            onClick={() => setSettings({...settings, snakeColor: id})}
                                        />
                                    ))}
                                </div>
                            </div>

                            <button className="menu-button" style={{marginTop: '40px'}} onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            if (screen === 'leaderboard') {
                return (
                    <div className="fullscreen">
                        <div className="leaderboard-container">
                            <div className="leaderboard-title">LEADERBOARD</div>
                            <div className="leaderboard-subtitle">
                                {leaderboardFilter.mode.toUpperCase()} â€¢ {leaderboardFilter.difficulty.toUpperCase()}
                            </div>
                            <p style={{ fontSize: '0.85em', color: '#888', marginTop: 4 }}>
                                Global rankings from Supabase. Each mode + difficulty has its own board.
                            </p>
                            <div className="leaderboard-filters">
                                <select 
                                    className="filter-select"
                                    value={leaderboardFilter.mode}
                                    onChange={(e) => setLeaderboardFilter({...leaderboardFilter, mode: e.target.value})}
                                >
                                    <option value="classic">Classic</option>
                                    <option value="walls">Walls</option>
                                    <option value="portal">Portal</option>
                                    <option value="speed">Speed</option>
                                    <option value="survival">Survival</option>
                                </select>
                                
                                <select 
                                    className="filter-select"
                                    value={leaderboardFilter.difficulty}
                                    onChange={(e) => setLeaderboardFilter({...leaderboardFilter, difficulty: e.target.value})}
                                >
                                    <option value="easy">Easy</option>
                                    <option value="medium">Medium</option>
                                    <option value="hard">Hard</option>
                                </select>
                            </div>
                            
                            <div key={`leaderboard-${leaderboardFilter.mode}-${leaderboardFilter.difficulty}`} className="leaderboard-list">
                                {loadingLeaderboard ? (
                                    <div style={{textAlign: 'center', color: 'var(--text-muted)', padding: '40px 20px'}}>
                                        Loading...
                                    </div>
                                ) : leaderboard.length === 0 ? (
                                    <div style={{textAlign: 'center', color: 'var(--text-muted)', padding: '40px 20px', fontSize: '1.1em'}}>
                                        No scores yet.<br/>
                                        Be the first!
                                    </div>
                                ) : (
                                    leaderboard.map((entry) => (
                                        <div key={`${entry.rank}-${entry.wallet}`} className="leaderboard-entry">
                                            <div className="entry-rank">#{entry.rank}</div>
                                            <div className="entry-name">{entry.name}</div>
                                            <div className="entry-score">{entry.score} ðŸŽ</div>
                                        </div>
                                    ))
                                )}
                            </div>

                            <button className="menu-button" onClick={() => setScreen('menu')}>
                                BACK TO MENU
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="fullscreen">
                    <div className="game-screen">
                        <div className="game-hud">
                            <div className="hud-left">
                                {settings.gameMode === 'io' ? (
                                    <>
                                        <div className="stat-pill" data-score-type="apples">
                                            <span className="label">LENGTH</span>
                                            <span>{Math.round((ioSnakes.find(s => s.id === 'player') || {}).bodyLength || 1)}</span>
                                        </div>
                                        <div className="io-leaderboard-hud">
                                            <div className="io-leaderboard-hud-title">Leaderboard</div>
                                            {(ioSnakes.length ? [...ioSnakes].sort((a, b) => (b.bodyLength || 1) - (a.bodyLength || 1)) : []).slice(0, 6).map((s, i) => (
                                                <div key={s.id} className={`io-leaderboard-row ${s.dead ? 'dead' : ''} ${s.id === 'player' ? 'player' : ''}`}>
                                                    <span className="io-rank">#{i + 1}</span>
                                                    <span className="io-name">{s.name}</span>
                                                    <span className="io-len">{Math.round(s.bodyLength || 1)}</span>
                                                </div>
                                            ))}
                                        </div>
                                    </>
                                ) : levelId ? (
                                    <>
                                        <div className="stat-pill" data-score-type="apples">
                                            <span className="label">LEVEL {levelId}</span>
                                            <span>{Number(foodEaten)} / {LEVELS[levelId - 1].targetApples}</span>
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        <div className="stat-pill" data-score-type="apples">
                                            <span className="label">SCORE</span>
                                            <span>{Number(foodEaten)}</span>
                                        </div>
                                        <div className="stat-pill">
                                            <span className="label">HIGH SCORE</span>
                                            {getHighScore(settings.gameMode, settings.difficulty)}
                                        </div>
                                    </>
                                )}
                                {!levelId && settings.gameMode === 'survival' && (
                                    <div className="stat-pill">
                                        <span className="label">TIME</span>
                                        {timer}s
                                    </div>
                                )}
                            </div>
                            {screen === 'playing' && (
                                <button className="pause-btn" onClick={() => setScreen('paused')}>
                                    PAUSE
                                </button>
                            )}
                        </div>

                        <div className="game-canvas-wrap">
                        <canvas
                            ref={canvasRef}
                            width={settings.gameMode === 'io' ? VIEWPORT_CELLS * cellSize : GRID_SIZE * cellSize}
                            height={settings.gameMode === 'io' ? VIEWPORT_CELLS * cellSize : GRID_SIZE * cellSize}
                        />
                        </div>
                        {screen === 'playing' && settings.gameMode === 'io' && (
                            <div
                                className="joystick-wrap"
                                ref={joystickBaseRef}
                                onPointerDown={(e) => {
                                    e.preventDefault();
                                    joystickActiveRef.current = true;
                                    e.currentTarget.setPointerCapture(e.pointerId);
                                }}
                                onPointerMove={(e) => {
                                    if (!joystickActiveRef.current || !joystickBaseRef.current) return;
                                    const rect = joystickBaseRef.current.getBoundingClientRect();
                                    const cx = rect.left + rect.width / 2;
                                    const cy = rect.top + rect.height / 2;
                                    let dx = e.clientX - cx;
                                    let dy = e.clientY - cy;
                                    const maxR = 30;
                                    const r = Math.hypot(dx, dy);
                                    if (r > maxR) {
                                        dx = dx * maxR / r;
                                        dy = dy * maxR / r;
                                    }
                                    setJoystickKnob({ x: dx, y: dy });
                                    const nr = Math.hypot(dx, dy);
                                    let jx = 0, jy = 0;
                                    if (nr > 0) {
                                        jx = dx / maxR;
                                        jy = dy / maxR;
                                        const len = Math.hypot(jx, jy) || 1;
                                        jx /= len;
                                        jy /= len;
                                    }
                                    joystickRef.current = { x: jx, y: jy };
                                }}
                                onPointerUp={(e) => {
                                    joystickActiveRef.current = false;
                                    e.currentTarget.releasePointerCapture(e.pointerId);
                                    setJoystickKnob({ x: 0, y: 0 });
                                    joystickRef.current = { x: 0, y: 0 };
                                }}
                                onPointerCancel={(e) => {
                                    joystickActiveRef.current = false;
                                    setJoystickKnob({ x: 0, y: 0 });
                                    joystickRef.current = { x: 0, y: 0 };
                                }}
                            >
                                <div className="joystick-base" />
                                <div className="joystick-knob" style={{ transform: `translate(calc(-50% + ${joystickKnob.x}px), calc(-50% + ${joystickKnob.y}px))` }} />
                            </div>
                        )}

                        {screen === 'paused' && (
                            <div className="overlay">
                                <div className="overlay-title">PAUSED</div>
                                <div className="overlay-buttons">
                                    <button className="overlay-button" onClick={() => setScreen('playing')}>
                                        RESUME
                                    </button>
                                    <button className="overlay-button secondary" onClick={() => setScreen('menu')}>
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}

                        {screen === 'levelComplete' && (
                            <div className="overlay">
                                <div className="overlay-title">LEVEL {levelId} COMPLETE!</div>
                                <div className="level-complete-stars">
                                    {'â˜…'.repeat(levelStars[levelId] || 0)}{'â˜†'.repeat(3 - (levelStars[levelId] || 0))}
                                </div>
                                <div className="overlay-score" style={{ marginTop: 0 }}>
                                    TIME <span>{levelCompleteTime.toFixed(1)}s</span>
                                </div>
                                <div className="overlay-buttons">
                                    {levelId < LEVELS.length && (
                                        <button className="overlay-button" onClick={() => startLevel(levelId + 1)}>
                                            NEXT LEVEL
                                        </button>
                                    )}
                                    <button className="overlay-button secondary" onClick={() => setScreen('levels')}>
                                        LEVEL SELECT
                                    </button>
                                    <button className="overlay-button secondary" onClick={() => { setLevelId(null); setScreen('menu'); }}>
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}

                        {screen === 'gameOver' && (
                            <div className="overlay">
                                <div className="overlay-title">GAME OVER</div>
                                {ioLeaderboard.length > 0 ? (
                                    <>
                                        <div className="overlay-score">
                                            YOUR LENGTH
                                            <span>{ioLeaderboard.find(e => e.isPlayer)?.length ?? 0}</span>
                                        </div>
                                        <div className="io-leaderboard-final">
                                            <div className="io-leaderboard-final-title">Final standings</div>
                                            {ioLeaderboard.map((e, i) => (
                                                <div key={i} className={`io-leaderboard-final-row ${e.isPlayer ? 'player' : ''}`}>
                                                    <span className="io-rank">#{i + 1}</span>
                                                    <span className="io-name">{e.name}</span>
                                                    <span className="io-len">{e.length}</span>
                                                </div>
                                            ))}
                                        </div>
                                    </>
                                ) : (
                                    <>
                                        <div className="overlay-score">
                                            FINAL SCORE
                                            <span>{Number(foodEaten)}</span>
                                        </div>
                                        {submittingScore && (
                                            <div className="loading-message">
                                                Submitting score...
                                            </div>
                                        )}
                                        {!wallet && !submittingScore && (
                                            <div style={{ fontSize: '0.9em', color: 'var(--text-muted)', marginTop: 8 }}>
                                                Connect wallet to save your score to the leaderboard.
                                            </div>
                                        )}
                                    </>
                                )}
                                <div className="overlay-buttons">
                                    <button 
                                        className="overlay-button" 
                                        onClick={levelId ? () => startLevel(levelId) : () => startGame({ gameMode: settings.gameMode, difficulty: settings.difficulty })}
                                        disabled={submittingScore}
                                    >
                                        PLAY AGAIN
                                    </button>
                                    <button 
                                        className="overlay-button secondary" 
                                        onClick={() => { setLevelId(null); setScreen('menu'); }}
                                        disabled={submittingScore}
                                    >
                                        MENU
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Safety check: Ensure React is loaded and root element exists
        function initApp() {
            const root = document.getElementById('root');
            if (!root) {
                console.error('âŒ Root element not found!');
                document.body.innerHTML = '<div style="color: white; padding: 20px; text-align: center; background: #000;">Error: Root element not found. Please refresh the page.</div>';
                return;
            }

            if (typeof React === 'undefined') {
                console.error('âŒ React not loaded!');
                root.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: React library failed to load. Please refresh the page.</div>';
                return;
            }

            if (typeof ReactDOM === 'undefined') {
                console.error('âŒ ReactDOM not loaded!');
                root.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: ReactDOM library failed to load. Please refresh the page.</div>';
                return;
            }

            console.log('âœ… React loaded:', typeof React !== 'undefined');
            console.log('âœ… ReactDOM loaded:', typeof ReactDOM !== 'undefined');
            console.log('âœ… Root element found:', !!root);

            try {
                ReactDOM.render(<SnakeGame />, root);
                console.log('âœ… App rendered successfully');
            } catch (error) {
                console.error('âŒ Error rendering app:', error);
                root.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Error: ' + error.message + '<br>Please check the console for details.</div>';
            }
        }

        // Wait for DOM and scripts to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            // DOM already ready, but wait a tick for scripts to load
            setTimeout(initApp, 0);
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js', { scope: './' }).catch(() => {});
            });
        }
    </script>
</body>
</html>
